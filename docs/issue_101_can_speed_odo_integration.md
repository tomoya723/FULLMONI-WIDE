# Issue #101: CAN車速受信時のオドメータパルス積算対応

## 概要

CAN経由で車速（km/h）を受信する構成において、車速パルス入力（MTU8）が存在しないため、オドメータ・トリップメータが積算されない問題を解決する。
CAN車速値から仮想パルス数を逆算し、既存のパルス積算変数（`sp_int`）に加算することで、ODO/TRIP/EEPROM保存のロジックを変更なしで動作させる。

## 背景

### 従来構成（車速パルス入力あり）

```
[MTU8パルス割り込み] → sp_int++ → ÷ PULSE_PER_KM → ODO/TRIP表示
                                        ↓
                                   EEPROM保存（生涯積算）
```

- MTU8が車速センサーパルスをキャプチャし、1パルスごとに `sp_int` をインクリメント
- `PULSE_PER_KM = 2548`（1km = 2548パルス）で除算してODO値を算出
- 法規準拠の高精度積算（パルス単位）

### CAN車速構成（本対応）

CAN ECU（MoTeC等）から車速値をkm/h単位で受信する場合、物理的な車速パルスが存在しない。
精度は妥協し、受信した車速値から仮想パルスを生成して既存積算ロジックに乗せる。

## 実装設計

### 処理フロー

```
┌─────────────────────────────────────────────────┐
│ 起動時 init_data_store()                        │
│  └─ g_speed_from_can = 1 (CAN車速有効時)        │
└─────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────┐
│ MTU8割り込み (車速パルス入力)                     │
│  └─ g_speed_from_can == 1 → return (スキップ)   │
│     g_speed_from_can == 0 → sp_int++ (従来通り)  │
└─────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────┐
│ process_can_fields() [data_store()内、FPS依存]   │
│  └─ CAN_TARGET_SPEED → g_CALC_data.sp = value   │
└─────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────┐
│ ap_50ms() → can_speed_to_pulse() [50ms定周期]   │
│  └─ g_speed_from_can == 1 の場合:               │
│     pulse = sp × PULSE_PER_KM × 0.05/3600       │
│           + 前回端数                              │
│     sp_int += (unsigned long)pulse               │
│     端数を次回に繰り越し                         │
└─────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────┐
│ 既存ODO/TRIP処理 (変更なし)                      │
│  odo = sp_int / PULSE_PER_KM                     │
│  trip = (sp_int - tr_int) / PULSE_PER_KM         │
│  EEPROM保存 → sp_int, tr_int をそのまま保存      │
└─────────────────────────────────────────────────┘
```

### 換算式

```
仮想パルス/50ms = speed[km/h] × (0.05 / 3600) × PULSE_PER_KM
```

マクロ定義:
```c
#define CAN_SPEED_PULSE_FACTOR  (PULSE_PER_KM * 0.05f / 3600.0f)
```

#### 計算例

| 車速 [km/h] | パルス/50ms | パルス/秒 | 検算 (km/h→km/s×PULSE_PER_KM) |
|-------------|------------|----------|-------------------------------|
| 60          | 2.123      | 42.47    | 60/3600×2548 = 42.47 ✓        |
| 100         | 3.539      | 70.78    | 100/3600×2548 = 70.78 ✓       |
| 200         | 7.078      | 141.56   | 200/3600×2548 = 141.56 ✓      |

### 端数繰り越し

整数パルスカウンタに小数値を積算するため、端数を `static float s_pulse_fraction` で次回に繰り越す。

```c
pulse_f = g_CALC_data.sp * CAN_SPEED_PULSE_FACTOR + s_pulse_fraction;
pulse_int = (unsigned long)pulse_f;
s_pulse_fraction = pulse_f - (float)pulse_int;
sp_int += pulse_int;
```

- 電源断時に失われる端数は最大1パルス未満（≈ 0.4m）で実用上無視可能
- 長距離走行でも理論値からのずれは1パルス未満に収まる

## 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `Firmware/src/dataregister.c` | `can_speed_to_pulse()` 関数新設、`g_speed_from_can` フラグ・端数変数・換算定数の定義 |
| `Firmware/src/dataregister.h` | `can_speed_to_pulse()` 関数宣言、`g_speed_from_can` extern宣言 |
| `Firmware/src/main.c` | `ap_50ms()` から `can_speed_to_pulse()` を呼び出し |
| `Firmware/src/smc_gen/Config_MTU8/Config_MTU8_user.c` | CAN車速有効時に `return` でパルス積算をスキップ |
| `Firmware/src/smc_gen/Config_MTU0/Config_MTU0_user.c` | CAN車速有効時にMTUパルス車速計算をスキップ |

## 関連変更（同一ブランチ）

- **車速表示のゼロ交互表示修正**: CAN車速受信時、MTU0割り込みの車速LPF計算が `g_CALC_data.sp` を上書きしていた問題を `g_speed_from_can` フラグでガード
- **車速表示補正の削除**: 法規対応（高速側表示）の `× 1.06` 補正を削除。CAN車速は物理値そのままを表示
- **ODO/TRIP計算のマジックナンバー排除**: `2548` → `PULSE_PER_KM` マクロに置換

## 精度に関する注意事項

| 項目 | MTUパルス（従来） | CAN車速（本対応） |
|------|------------------|------------------|
| 計測原理 | パルスカウント | 車速値からの逆算 |
| 精度 | パルス単位（高精度） | 50ms周期サンプリング（妥協） |
| 最大誤差要因 | なし | CAN送信周期とのジッター |
| 電源断時損失 | なし | 最大1パルス（≈ 0.4m） |

CAN車速の送信周期とap_50ms()は非同期だが、車速の時間軸方向の変化は緩やかなため、実用上問題ない。

## 関連Issue

- Issue #65: CAN設定のカスタム化対応
- Issue #50: マスターワーニング

## テスト結果（2026/02/12 実機確認）

| テスト | 内容 | 結果 |
|--------|------|------|
| テスト3 | 100km/h × 6分 → ODO +10km（精度確認） | ✅ OK |
| テスト4 | 0km/h × 1分 → ODO変化なし（停車時誤積算防止） | ✅ OK |
| テスト5 | 電源サイクル後のODO/TRIP保持（EEPROM保存確認） | ✅ OK |
| テスト6 | MTUパルス非干渉確認（車速表示のゼロ交互なし） | ✅ OK |
