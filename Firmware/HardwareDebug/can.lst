   1                             		.file	"can.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.text.test_leds,"ax",@progbits
   6                             	_test_leds:
   7                             	.LVL0:
   8                             	.LFB10:
   9                             		.file 1 "../src/can.c"
   1:../src/can.c  **** /**************************************************************************************************
   2:../src/can.c  **** * DISCLAIMER
   3:../src/can.c  **** * This software is supplied by Renesas Electronics Corporation and is only intended for use with Re
   4:../src/can.c  **** * other uses are authorized. This software is owned by Renesas Electronics Corporation and is prote
   5:../src/can.c  **** * applicable laws, including copyright laws.
   6:../src/can.c  **** * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
   7:../src/can.c  **** * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF 
   8:../src/can.c  **** * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIM
   9:../src/can.c  **** * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AF
  10:../src/can.c  **** * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY RE
  11:../src/can.c  **** * SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
  12:../src/can.c  **** * Renesas reserves the right, without notice, to make changes to this software and to discontinue t
  13:../src/can.c  **** * this software. By using this software, you agree to the additional terms and conditions found by 
  14:../src/can.c  **** * following link:
  15:../src/can.c  **** * http://www.renesas.com/disclaimer
  16:../src/can.c  **** *
  17:../src/can.c  **** * Copyright (C) 2015 Renesas Electronics Corporation. All rights reserved.
  18:../src/can.c  **** ***************************************************************************************************
  19:../src/can.c  **** /**************************************************************************************************
  20:../src/can.c  **** * File Name    : can.c
  21:../src/can.c  **** * Description  : CAN API demo. Main application program. See operation below under DEMO DESCRIPTION
  22:../src/can.c  **** 
  23:../src/can.c  **** CAN Baudrate: 500 kbps.
  24:../src/can.c  **** 
  25:../src/can.c  **** Demonstration of CAN receive and transmit using the CAN API.
  26:../src/can.c  **** 
  27:../src/can.c  **** The demo can be run in three ways:
  28:../src/can.c  **** 1.  Program two boards and connect them together over the CAN bus. Swap the CAN ID values TX_CANID_
  29:../src/can.c  **** RX_CANID_DEMO_INIT on one of the boards before programming and running the demo.
  30:../src/can.c  **** 2) Set CANPORT_TEST_1_INT_LOOPBACK in the R_CAN_PortSet API to communicate internally, no external 
  31:../src/can.c  **** 3) Use a CAN bus monitor, e.g. SysTec's low-cost monitor 3204000, to send and receive frames to/fro
  32:../src/can.c  **** Remote frames can also be demonstrated if CAN interrupts are enabled. See last paragraph below.
  33:../src/can.c  **** 
  34:../src/can.c  **** OPERATION:
  35:../src/can.c  **** The demo transmits and receives frames with the default CAN-IDs TX_CANID_DEMO_INIT and RX_CANID_DEM
  36:../src/can.c  **** 
  37:../src/can.c  **** The demo starts up by sending NR_STARTUP_TEST_FRAMES test frames back-to-back as fast as possible. 
  38:../src/can.c  **** purposes. 1) Check the bus link. 2) Demonstrate how messages are sent back-to-back as fast as possi
  39:../src/can.c  **** 
  40:../src/can.c  **** User action: Press SW1 to send one CAN frame. To increment the TxID hold SW2 down and press SW3. Th
  41:../src/can.c  **** command is invoked by the Sw1Func() function. To change RxID hold SW3 down and press SW2. The demo 
  42:../src/can.c  **** be seen inside function can_int_demo or can_poll_demo (depending on the setting of USE_CAN_POLL in 
  43:../src/can.c  **** 
  44:../src/can.c  **** Remote frames:
  45:../src/can.c  **** The demo will also send remote frame responses if REMOTE_DEMO_ENABLE is set to 1 in can_api_demo.c.
  46:../src/can.c  **** CAN source must be set to send remote frame requests with CAN-ID 50h (REMOTE_TEST_ID in can_api_dem
  47:../src/can.c  **** The remote frames demo only runs in interrupt mode (USE_CAN_POLL set to 1.
  48:../src/can.c  **** * *************************************************************************************************
  49:../src/can.c  **** * History : DD.MM.YYYY Version Description
  50:../src/can.c  **** *         : 20.02.2015 2.01    For 64M, 71M. Originates from RX63N.
  51:../src/can.c  **** *         : 30.10.2015 2.02    FIT update, new R_CAN_Create interface.
  52:../src/can.c  **** *         : 03.03.2016 2.10    65N added.
  53:../src/can.c  **** *         : 30.01.2017 2.11    - Test run with 65N-2MB.
  54:../src/can.c  **** *                              - Added ERROR_DIAG macro. Use for bus error diagnostics only.
  55:../src/can.c  **** *                              - Removed all USE_LCD code. Using debug console (printf) instead.
  56:../src/can.c  **** *                                Added corresponding trace code to demo.
  57:../src/can.c  **** *                              - Function names changed_to_this_style().
  58:../src/can.c  **** *                              - Cleaned up handle_can_bus_state().
  59:../src/can.c  **** *                              - Some GSCE coding guidelines implemented. Mulitple lines changed. (
  60:../src/can.c  **** *         : 04.01.2021 4.10    - Updated demo for CAN V4.10.
  61:../src/can.c  **** *         : 01.04.2021 5.00    - Updated demo for CAN V5.00.
  62:../src/can.c  **** ***************************************************************************************************
  63:../src/can.c  **** /**************************************************************************************************
  64:../src/can.c  **** Includes   <System Includes> , "Project Includes"
  65:../src/can.c  **** ***************************************************************************************************
  66:../src/can.c  **** #include <can.h>
  67:../src/can.c  **** #include "platform.h"
  68:../src/can.c  **** #include "r_can_rx_if.h"
  69:../src/can.c  **** #include "r_can_rx_config.h"
  70:../src/can.c  **** #include <stdio.h>
  71:../src/can.c  **** #include "cmt_dev.h"	/* AP add */
  72:../src/can.c  **** 
  73:../src/can.c  **** 
  74:../src/can.c  **** /**************************************************************************************************
  75:../src/can.c  **** Typedef definitions
  76:../src/can.c  **** ***************************************************************************************************
  77:../src/can.c  **** /**************************************************************************************************
  78:../src/can.c  **** Macro definitions
  79:../src/can.c  **** ***************************************************************************************************
  80:../src/can.c  **** /* TEST CAN ID */
  81:../src/can.c  **** #if (FRAME_ID_MODE == STD_ID_MODE)
  82:../src/can.c  ****     #define     TX_CANID_DEMO_INIT  	(0x0A0)    // Max 0x7FF if Standard ID.
  83:../src/can.c  **** //  #define     RX_CANID_DEMO_INIT    	(0x3E8)    // "-
  84:../src/can.c  ****     #define     RX_CANID_DEMO_INIT1    	(0x3E8)    // MoTeC m100 #1
  85:../src/can.c  ****     #define     RX_CANID_DEMO_INIT2    	(0x3E9)    // MoTeC m100 #2
  86:../src/can.c  ****     #define     RX_CANID_DEMO_INIT3    	(0x3EA)    // MoTeC m100 #3
  87:../src/can.c  ****     #define     RX_CANID_DEMO_INIT4    	(0x3EB)    // MoTeC m100 #4
  88:../src/can.c  ****     #define     RX_CANID_DEMO_INIT5    	(0x3EC)    // MoTeC m100 #5
  89:../src/can.c  ****     #define     RX_CANID_DEMO_INIT6    	(0x3ED)    // MoTeC m100 #6
  90:../src/can.c  **** #else
  91:../src/can.c  ****     #define     TX_CANID_DEMO_INIT     	(uint32_t)(0x000A0000)    ///Max 0x20000000 if Extended CAN
  92:../src/can.c  ****     #define     RX_CANID_DEMO_INIT     	(uint32_t)(0x000A0001)    // "-
  93:../src/can.c  **** #endif
  94:../src/can.c  **** 
  95:../src/can.c  **** #ifdef CAN2 // Three CAN channels exist on device.
  96:../src/can.c  ****     #define     NR_CAN_CHANNELS             (3)
  97:../src/can.c  **** #else
  98:../src/can.c  **** #ifdef CAN1 // Two CAN channels exist.
  99:../src/can.c  ****     #define     NR_CAN_CHANNELS             (2)
 100:../src/can.c  **** #else       // One CAN channel.
 101:../src/can.c  ****     #define     NR_CAN_CHANNELS             (1)
 102:../src/can.c  **** #endif
 103:../src/can.c  **** #endif
 104:../src/can.c  **** 
 105:../src/can.c  **** #define     NR_STARTUP_TEST_FRAMES      (99)
 106:../src/can.c  **** #define     NR_LOOPS_RESET_LEDS         (0x00020000)
 107:../src/can.c  **** #define     LED_DELAY                   (0x00200000)
 108:../src/can.c  **** 
 109:../src/can.c  **** #define     REMOTE_DEMO_ENABLE          (0)   /* 1 on, 0 off. */
 110:../src/can.c  **** #define     REMOTE_TEST_ID              (0x050)
 111:../src/can.c  **** 
 112:../src/can.c  **** /* Declares the baud rate prescaler division and bit timing values for CAN0 */
 113:../src/can.c  **** // CAN bautrate 500kbps
 114:../src/can.c  **** //#define CAN0_BRP   (5)
 115:../src/can.c  **** //#define CAN0_SJW   (2)
 116:../src/can.c  **** //#define CAN0_TSEG1 (15)
 117:../src/can.c  **** //#define CAN0_TSEG2 (8)
 118:../src/can.c  **** // CAN bautrate 1Mbps
 119:../src/can.c  **** #define CAN0_BRP   (5)
 120:../src/can.c  **** #define CAN0_SJW   (2)
 121:../src/can.c  **** #define CAN0_TSEG1 (7)
 122:../src/can.c  **** #define CAN0_TSEG2 (4)
 123:../src/can.c  **** 
 124:../src/can.c  **** /* Use this to aid in diagnose of problematic CAN bus.
 125:../src/can.c  ****  * Do *NOT* use in production unless error diagnostics is desired in end product.
 126:../src/can.c  ****  * Observe that CAN recovers by itself if things return to mormal, and
 127:../src/can.c  ****  * CAN bus states Error Passive and Bus Off are handled by handle_can_bus_state(). */
 128:../src/can.c  **** #define     ERROR_DIAG                  (0)   /* 1 on, 0 off. USE_CAN_POLL must be 0 if on. */
 129:../src/can.c  **** 
 130:../src/can.c  **** #define SEND_TIME_INTERVAL 5000		/* AP add */
 131:../src/can.c  **** 
 132:../src/can.c  **** /**************************************************************************************************
 133:../src/can.c  ****  * Exported global variables
 134:../src/can.c  **** ***************************************************************************************************
 135:../src/can.c  **** /* Demo data */
 136:../src/can.c  **** can_frame_t	tx_dataframe,
 137:../src/can.c  **** //			rx_dataframe,
 138:../src/can.c  **** 			rx_dataframe1,
 139:../src/can.c  **** 			rx_dataframe2,
 140:../src/can.c  **** 			rx_dataframe3,
 141:../src/can.c  **** 			rx_dataframe4,
 142:../src/can.c  **** 			rx_dataframe5,
 143:../src/can.c  **** 			rx_dataframe6,
 144:../src/can.c  **** 			remote_frame;
 145:../src/can.c  **** 
 146:../src/can.c  **** /* RSK+ 64M uses CAN0 (channel 0). */
 147:../src/can.c  **** uint32_t    g_can_channel = CH_0;		/* AP change */
 148:../src/can.c  **** /* AP-RX72N-0A uses CAN1 (channel 1). */
 149:../src/can.c  **** //uint32_t    g_can_channel = CH_1;		/* AP change */
 150:../src/can.c  **** 
 151:../src/can.c  **** /* CAN mailbox mode */
 152:../src/can.c  **** uint32_t    g_mb_mode = CANBOX_NORMAL; /* Normal mailbox */
 153:../src/can.c  **** 
 154:../src/can.c  **** /* CAN0 bitrate configure */
 155:../src/can.c  **** can_bitrate_config_t CAN0_bitrate_cfg;
 156:../src/can.c  **** 
 157:../src/can.c  **** /* Flags set by the CAN ISRs, so the user app knows it has data tp process.
 158:../src/can.c  ****  * Polled mode will poll the mailboxes instead. */
 159:../src/can.c  **** #if !USE_CAN_POLL
 160:../src/can.c  **** uint32_t    CAN0_tx_sentdata_flag = 0;
 161:../src/can.c  **** uint32_t    CAN0_rx_newdata_flag = 0;
 162:../src/can.c  **** uint32_t    CAN0_tx_remote_sentdata_flag = 0;
 163:../src/can.c  **** uint32_t    CAN0_rx_remote_frame_flag = 0;
 164:../src/can.c  **** #endif
 165:../src/can.c  **** 
 166:../src/can.c  **** /* Application layer logic error container. Use as desired to record issues. */
 167:../src/can.c  **** enum app_err_enum   app_err_nr;
 168:../src/can.c  **** 
 169:../src/can.c  **** extern uint32_t g_can_channel;		/* AP add */
 170:../src/can.c  **** 
 171:../src/can.c  **** /**************************************************************************************************
 172:../src/can.c  **** Global variables and functions imported (externs)
 173:../src/can.c  **** ***************************************************************************************************
 174:../src/can.c  **** /* Data */
 175:../src/can.c  **** /* Functions */
 176:../src/can.c  **** extern void   read_switches(void);
 177:../src/can.c  **** void R_CAN_PinSet_CAN0();
 178:../src/can.c  **** //void R_CAN_PinSet_CAN1();
 179:../src/can.c  **** 
 180:../src/can.c  **** /**************************************************************************************************
 181:../src/can.c  **** Private global variables and functions
 182:../src/can.c  **** ***************************************************************************************************
 183:../src/can.c  **** /* Errors. Peripheral and bus errors. Space for each channel. */
 184:../src/can.c  **** static uint32_t error_bus_status[NR_CAN_CHANNELS];
 185:../src/can.c  **** static uint32_t error_bus_status_prev[NR_CAN_CHANNELS];
 186:../src/can.c  **** static uint32_t can_state[NR_CAN_CHANNELS];
 187:../src/can.c  **** static uint32_t nr_times_reached_busoff[NR_CAN_CHANNELS];
 188:../src/can.c  **** 
 189:../src/can.c  **** /* Counts demo frames sent and received. */
 190:../src/can.c  **** static uint32_t nr_frames_rx = 0, nr_frames_tx = 0;
 191:../src/can.c  **** 
 192:../src/can.c  **** /* Functions */
 193:../src/can.c  **** static uint32_t init_can_app(void);
 194:../src/can.c  **** static void     check_can_errors(void);
 195:../src/can.c  **** static void     handle_can_bus_state(uint8_t ch_nr);
 196:../src/can.c  **** static void     test_leds(uint32_t nr_led_flashes);
 197:../src/can.c  **** static void     demo_output_ports_configure(void);
 198:../src/can.c  **** 
 199:../src/can.c  **** #if USE_CAN_POLL
 200:../src/can.c  ****  static void    can_poll_demo(void);
 201:../src/can.c  **** #else
 202:../src/can.c  ****  static void can_int_demo(void);
 203:../src/can.c  ****  static void my_can_tx0_callback(void);
 204:../src/can.c  ****  static void my_can_rx0_callback(void);
 205:../src/can.c  ****  static void my_can_err0_callback(void);
 206:../src/can.c  **** #endif
 207:../src/can.c  **** 
 208:../src/can.c  **** /**************************************************************************************************
 209:../src/can.c  **** Function name:  main
 210:../src/can.c  **** Parameters:     -
 211:../src/can.c  **** Returns:        -
 212:../src/can.c  **** Description:    Main Can API demo program. See top of file.
 213:../src/can.c  **** ***************************************************************************************************
 214:../src/can.c  **** //void main(void)
 215:../src/can.c  **** void Init_CAN(void)
 216:../src/can.c  **** {
 217:../src/can.c  ****   uint32_t  api_status = R_CAN_OK;
 218:../src/can.c  **** //  uint32_t  i, bus_status;
 219:../src/can.c  **** //	volatile uint32_t timer, timer_tmp;
 220:../src/can.c  **** 
 221:../src/can.c  ****     #if BSP_CFG_IO_LIB_ENABLE
 222:../src/can.c  ****         printf("\n\nStarting Tx-Rx Demo...\n");
 223:../src/can.c  ****         printf("R_CAN_Create() for channel %d, and provided user callback funcs.\n", g_can_channel)
 224:../src/can.c  ****     #endif
 225:../src/can.c  **** 
 226:../src/can.c  ****     demo_output_ports_configure();
 227:../src/can.c  **** 
 228:../src/can.c  ****     /* Blink LEDs. */
 229:../src/can.c  ****     test_leds(30);
 230:../src/can.c  **** 
 231:../src/can.c  ****     /* Config bitrate for CAN0*/
 232:../src/can.c  ****     CAN0_bitrate_cfg.BRP = CAN0_BRP;
 233:../src/can.c  ****     CAN0_bitrate_cfg.SJW = CAN0_SJW;
 234:../src/can.c  ****     CAN0_bitrate_cfg.TSEG1 = CAN0_TSEG1;
 235:../src/can.c  ****     CAN0_bitrate_cfg.TSEG2 = CAN0_TSEG2;
 236:../src/can.c  **** 
 237:../src/can.c  ****     /* Init CAN. */
 238:../src/can.c  ****     #if USE_CAN_POLL
 239:../src/can.c  ****         api_status = R_CAN_Create(g_can_channel, g_mb_mode, CAN0_bitrate_cfg, NULL, NULL, NULL, NUL
 240:../src/can.c  ****     #else
 241:../src/can.c  ****         api_status = R_CAN_Create(g_can_channel, g_mb_mode, CAN0_bitrate_cfg, my_can_tx0_callback, 
 242:../src/can.c  ****     #endif
 243:../src/can.c  **** 
 244:../src/can.c  ****     if (api_status != R_CAN_OK)
 245:../src/can.c  ****     {
 246:../src/can.c  ****         /* An error at this stage is fatal to demo, so stop here. */
 247:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 248:../src/can.c  ****             printf("Demo init error.\n\n");
 249:../src/can.c  ****         #endif
 250:../src/can.c  ****         while (1)
 251:../src/can.c  ****         {
 252:../src/can.c  ****             /* Stop here and leave error displayed. */
 253:../src/can.c  ****         }
 254:../src/can.c  ****     }
 255:../src/can.c  **** 
 256:../src/can.c  ****     /****************************************
 257:../src/can.c  ****     * Pick ONE R_CAN_PortSet call below!    *
 258:../src/can.c  ****     *****************************************/
 259:../src/can.c  ****     /* Normal CAN bus usage. */
 260:../src/can.c  ****     R_CAN_PinSet_CAN0();
 261:../src/can.c  **** //    R_CAN_PinSet_CAN1();
 262:../src/can.c  ****     /* Test modes. With Internal loopback mode you only need one board! */
 263:../src/can.c  ****     //api_status = R_CAN_PortSet(g_can_channel, ENABLE);
 264:../src/can.c  ****     //api_status = R_CAN_PortSet(g_can_channel, CANPORT_TEST_1_INT_LOOPBACK);
 265:../src/can.c  ****     //api_status = R_CAN_PortSet(g_can_channel, CANPORT_TEST_0_EXT_LOOPBACK);
 266:../src/can.c  ****     //api_status = R_CAN_PortSet(g_can_channel, CANPORT_TEST_LISTEN_ONLY);
 267:../src/can.c  **** 
 268:../src/can.c  ****     /* Initialize CAN mailboxes, and setup the demo receive and transmit dataframe variables. */
 269:../src/can.c  ****     api_status |= init_can_app();
 270:../src/can.c  **** 
 271:../src/can.c  ****     /* Is all OK after all CAN initialization? */
 272:../src/can.c  ****     if (api_status != R_CAN_OK)
 273:../src/can.c  ****     {
 274:../src/can.c  ****         api_status = R_CAN_OK;
 275:../src/can.c  ****         app_err_nr = APP_ERR_CAN_INIT;
 276:../src/can.c  ****     }
 277:../src/can.c  **** 
 278:../src/can.c  ****     /***************************************************
 279:../src/can.c  ****      * Try to send very first frame. Stop if no success.
 280:../src/can.c  ****      ***************************************************/
 281:../src/can.c  **** //    if (FRAME_ID_MODE == STD_ID_MODE )
 282:../src/can.c  **** //    {
 283:../src/can.c  ****         R_CAN_Control(g_can_channel, OPERATE_CANMODE);
 284:../src/can.c  **** //        api_status |= R_CAN_TxSet(g_can_channel, g_mb_mode, CANBOX_TX, &tx_dataframe, DATA_FRAME)
 285:../src/can.c  **** //    }
 286:../src/can.c  **** //    else
 287:../src/can.c  **** //    {
 288:../src/can.c  **** //        api_status |= R_CAN_TxSetXid(g_can_channel, g_mb_mode, CANBOX_TX, &tx_dataframe, DATA_FRA
 289:../src/can.c  **** //    }
 290:../src/can.c  **** //
 291:../src/can.c  **** //    /* Don't continue if problem already. */
 292:../src/can.c  **** //    if (api_status != R_CAN_OK)
 293:../src/can.c  **** //    {
 294:../src/can.c  **** //        while(1)
 295:../src/can.c  **** //            ;
 296:../src/can.c  **** //    }
 297:../src/can.c  **** //
 298:../src/can.c  **** //    /* Wait for first frame to be sent. */
 299:../src/can.c  **** //    #if USE_CAN_POLL
 300:../src/can.c  **** //    while (R_CAN_TxCheck(g_can_channel, CANBOX_TX))
 301:../src/can.c  **** //    #else
 302:../src/can.c  **** //    while (CAN0_tx_sentdata_flag == 0)
 303:../src/can.c  **** //    #endif
 304:../src/can.c  **** //    {
 305:../src/can.c  **** //        /* If Bus Off, wait until cleared. If it never does, bus is broke. */
 306:../src/can.c  **** //        bus_status = R_CAN_CheckErr(g_can_channel);
 307:../src/can.c  **** //        while (bus_status == R_CAN_STATUS_BUSOFF)
 308:../src/can.c  **** //        {
 309:../src/can.c  **** //            bus_status = R_CAN_CheckErr(g_can_channel);
 310:../src/can.c  **** //        }
 311:../src/can.c  **** //    }
 312:../src/can.c  ****     /************************
 313:../src/can.c  ****      * OK!! Sent one frame! *
 314:../src/can.c  ****      ************************/
 315:../src/can.c  **** //    #if BSP_CFG_IO_LIB_ENABLE
 316:../src/can.c  **** //        printf("Success! Sent first CAN frame.\n");
 317:../src/can.c  **** //    #endif
 318:../src/can.c  **** //
 319:../src/can.c  **** //    /******************************************************************
 320:../src/can.c  **** //     * Send multiple CAN test frames back to back as fast as possible.
 321:../src/can.c  **** //     *****************************************************************/
 322:../src/can.c  **** //    #if USE_CAN_POLL /* ============================================================= */
 323:../src/can.c  **** //    for (i = 0; i < NR_STARTUP_TEST_FRAMES; i++)
 324:../src/can.c  **** //    {
 325:../src/can.c  **** //        api_status |= R_CAN_Tx(g_can_channel, g_mb_mode, CANBOX_TX);
 326:../src/can.c  **** //        while (R_CAN_TxCheck(g_can_channel, CANBOX_TX))
 327:../src/can.c  **** //        {
 328:../src/can.c  **** //            R_BSP_NOP();
 329:../src/can.c  **** //        }
 330:../src/can.c  **** //    }
 331:../src/can.c  **** //    #if BSP_CFG_IO_LIB_ENABLE
 332:../src/can.c  **** //        printf("Sent %d CAN0 frames.\n", NR_STARTUP_TEST_FRAMES);
 333:../src/can.c  **** //    #endif
 334:../src/can.c  **** //
 335:../src/can.c  **** //    #else /* Use CAN interrupts
 336:../src/can.c  **** //    I-flag is set by default.
 337:../src/can.c  **** //
 338:../src/can.c  **** //    CAN tx interrupt should have triggered by first frame. */
 339:../src/can.c  **** //    while (CAN0_tx_sentdata_flag == 0)
 340:../src/can.c  **** //    {
 341:../src/can.c  **** //        R_BSP_NOP();
 342:../src/can.c  **** //    }
 343:../src/can.c  **** //    CAN0_tx_sentdata_flag = 0;
 344:../src/can.c  **** //
 345:../src/can.c  **** //    for (i = 0; i < NR_STARTUP_TEST_FRAMES; i++)
 346:../src/can.c  **** //    {
 347:../src/can.c  **** //        api_status |= R_CAN_Tx(g_can_channel, g_mb_mode, CANBOX_TX);
 348:../src/can.c  **** //        while (CAN0_tx_sentdata_flag == 0)
 349:../src/can.c  **** //        {
 350:../src/can.c  **** //            R_BSP_NOP();
 351:../src/can.c  **** //        }
 352:../src/can.c  **** //        CAN0_tx_sentdata_flag = 0;
 353:../src/can.c  **** //    }
 354:../src/can.c  **** //    #if BSP_CFG_IO_LIB_ENABLE
 355:../src/can.c  **** //        printf("Sent %d CAN0 frames.\n", NR_STARTUP_TEST_FRAMES);
 356:../src/can.c  **** //    #endif
 357:../src/can.c  **** //    #endif  /* === End send startup test frames === */
 358:../src/can.c  **** }
 359:../src/can.c  **** 
 360:../src/can.c  **** void main_CAN(void)
 361:../src/can.c  **** {
 362:../src/can.c  **** 	uint32_t  led_show_count;
 363:../src/can.c  **** //	uint32_t  api_status = R_CAN_OK;
 364:../src/can.c  **** //	volatile uint32_t timer, timer_tmp;
 365:../src/can.c  **** 
 366:../src/can.c  ****     /*  M A I N  L O O P  * * * * * * * * * * * * * * * * * * * * * * * */
 367:../src/can.c  **** //  while(1)
 368:../src/can.c  **** //  {
 369:../src/can.c  ****         /* User pressing switch(es)? */
 370:../src/can.c  **** //        read_switches();		/* AP change */
 371:../src/can.c  **** 	//	timer_tmp = GetCmt1msecCounter();
 372:../src/can.c  **** 	//	if((timer_tmp - timer) > SEND_TIME_INTERVAL)
 373:../src/can.c  **** 	//	{
 374:../src/can.c  **** 	//	    tx_dataframe.data[0]++;
 375:../src/can.c  **** 	//	    if (FRAME_ID_MODE == STD_ID_MODE )
 376:../src/can.c  **** 	//	    {
 377:../src/can.c  **** 	//	        R_CAN_Control(g_can_channel, OPERATE_CANMODE);
 378:../src/can.c  **** 	//	        api_status |= R_CAN_TxSet(g_can_channel, g_mb_mode, CANBOX_TX, &tx_dataframe, DATA_FRAM
 379:../src/can.c  **** 	//	    }
 380:../src/can.c  **** 	//	    else
 381:../src/can.c  **** 	//	    {
 382:../src/can.c  **** 	//	        api_status |= R_CAN_TxSetXid(g_can_channel, g_mb_mode, CANBOX_TX, &tx_dataframe, DATA_F
 383:../src/can.c  **** 	//	    }
 384:../src/can.c  **** 	//
 385:../src/can.c  **** 	//	    /* Don't continue if problem already. */
 386:../src/can.c  **** 	//	    if (api_status != R_CAN_OK)
 387:../src/can.c  **** 	//	    {
 388:../src/can.c  **** 	//	        while(1)
 389:../src/can.c  **** 	//	            ;
 390:../src/can.c  **** 	//	    }
 391:../src/can.c  **** 	//
 392:../src/can.c  **** 	//		timer = GetCmt1msecCounter();
 393:../src/can.c  **** 	//	}
 394:../src/can.c  **** 
 395:../src/can.c  ****         /* Check for CAN errors. */
 396:../src/can.c  ****         check_can_errors();
 397:../src/can.c  **** 
 398:../src/can.c  ****         if (can_state[0] != R_CAN_STATUS_BUSOFF)
 399:../src/can.c  ****         {
 400:../src/can.c  ****             #if USE_CAN_POLL
 401:../src/can.c  ****             can_poll_demo();
 402:../src/can.c  ****             #else
 403:../src/can.c  ****             can_int_demo();
 404:../src/can.c  ****             #endif
 405:../src/can.c  ****         }
 406:../src/can.c  ****         else
 407:../src/can.c  ****         /* Bus Off. */
 408:../src/can.c  ****         {
 409:../src/can.c  ****             /* handle_can_bus_state() will restart application. */
 410:../src/can.c  ****             #if BSP_CFG_IO_LIB_ENABLE
 411:../src/can.c  ****                 printf("CAN IN BUSOFF :-(\n");
 412:../src/can.c  ****             #endif
 413:../src/can.c  ****         }
 414:../src/can.c  ****         /* Reset receive/transmit indication every so often. */
 415:../src/can.c  ****         if (led_show_count++ > NR_LOOPS_RESET_LEDS)
 416:../src/can.c  ****         {
 417:../src/can.c  ****             led_show_count = 0;
 418:../src/can.c  ****             LED0 = LED_OFF;
 419:../src/can.c  ****             LED1 = LED_OFF;
 420:../src/can.c  ****         }
 421:../src/can.c  **** //  }
 422:../src/can.c  **** }/* end main() */
 423:../src/can.c  **** 
 424:../src/can.c  **** #if USE_CAN_POLL
 425:../src/can.c  **** /*****************************************************************************
 426:../src/can.c  **** Function name:  can_poll_demo
 427:../src/can.c  **** Parameters:     -
 428:../src/can.c  **** Returns:        -
 429:../src/can.c  **** Description:    POLLED CAN demo version
 430:../src/can.c  **** *****************************************************************************/
 431:../src/can.c  **** static void can_poll_demo(void)
 432:../src/can.c  **** {
 433:../src/can.c  ****     uint32_t    api_status = R_CAN_OK;
 434:../src/can.c  **** 
 435:../src/can.c  ****     /*** TRANSMITTED any frames? */
 436:../src/can.c  ****     api_status = R_CAN_TxCheck(g_can_channel, CANBOX_TX);
 437:../src/can.c  ****     if (api_status == R_CAN_OK)
 438:../src/can.c  ****     {
 439:../src/can.c  ****         nr_frames_tx++;
 440:../src/can.c  ****         LED1 = LED_ON;
 441:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 442:../src/can.c  ****             printf("TxChk OK\n");
 443:../src/can.c  ****             printf("Sent frame. nr_frames_tx = %d.\n", nr_frames_tx);
 444:../src/can.c  ****         #endif
 445:../src/can.c  ****     }
 446:../src/can.c  **** 
 447:../src/can.c  ****     /* Since we are always polling for transmits, api_status for R_CAN_TxCheck
 448:../src/can.c  ****       will most often be other than R_CAN_OK, don't show that in this demo.*/
 449:../src/can.c  **** 
 450:../src/can.c  ****     /*** RECEIVED any frames? */
 451:../src/can.c  ****     api_status = R_CAN_RxPoll(g_can_channel, CANBOX_RX);
 452:../src/can.c  ****     if (api_status == R_CAN_OK)
 453:../src/can.c  ****     {
 454:../src/can.c  ****         nr_frames_rx++;
 455:../src/can.c  ****         LED0 = LED_ON;
 456:../src/can.c  **** 
 457:../src/can.c  ****         /* Read CAN data and show. */
 458:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX, &rx_dataframe);
 459:../src/can.c  **** 
 460:../src/can.c  ****         /* You can set BP here and check the received data in debugger. */
 461:../src/can.c  ****         R_BSP_NOP();
 462:../src/can.c  **** 
 463:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 464:../src/can.c  ****             printf("Received CAN ID 0x%X, nr_frames_rx = %d.\n", rx_dataframe.id, nr_frames_rx);
 465:../src/can.c  ****         #endif
 466:../src/can.c  ****         if (api_status == R_CAN_MSGLOST)
 467:../src/can.c  ****         {
 468:../src/can.c  ****             #if BSP_CFG_IO_LIB_ENABLE
 469:../src/can.c  ****                 printf( "MSGLOST\n");
 470:../src/can.c  ****             #endif
 471:../src/can.c  ****             R_BSP_NOP();
 472:../src/can.c  ****         }
 473:../src/can.c  ****     }
 474:../src/can.c  **** }/* end can_poll_demo() */
 475:../src/can.c  **** 
 476:../src/can.c  **** #else
 477:../src/can.c  **** 
 478:../src/can.c  **** /*****************************************************************************
 479:../src/can.c  **** Function name:      can_int_demo
 480:../src/can.c  **** Parameters:         -
 481:../src/can.c  **** Returns:            -
 482:../src/can.c  **** Description:        INTERRUPT driven CAN demo version.
 483:../src/can.c  **** *****************************************************************************/
 484:../src/can.c  **** static void can_int_demo(void)
 485:../src/can.c  **** {
 486:../src/can.c  ****     uint32_t    api_status = R_CAN_OK;
 487:../src/can.c  **** 
 488:../src/can.c  ****     /*** TRANSMITTED any frames? Only need to check if flag is set by CAN Tx ISR. */
 489:../src/can.c  ****     if (CAN0_tx_sentdata_flag)
 490:../src/can.c  ****     {
 491:../src/can.c  ****         CAN0_tx_sentdata_flag = 0;
 492:../src/can.c  ****         LED1 = LED_ON;
 493:../src/can.c  ****         nr_frames_tx++;
 494:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 495:../src/can.c  ****             printf("Sent frame. nr_frames_tx = %d.\n", nr_frames_tx);
 496:../src/can.c  ****         #endif
 497:../src/can.c  ****     }
 498:../src/can.c  **** 
 499:../src/can.c  ****     /*** RECEIVED any frames? Only need to check if flag is set by CAN Rx ISR.
 500:../src/can.c  ****      Will only receive own frames in CAN port test modes 0 and 1. */
 501:../src/can.c  ****     if (CAN0_rx_newdata_flag)
 502:../src/can.c  ****     {
 503:../src/can.c  ****         CAN0_rx_newdata_flag = 0;
 504:../src/can.c  ****         LED0 = LED_ON;
 505:../src/can.c  ****         nr_frames_rx++;
 506:../src/can.c  **** 
 507:../src/can.c  ****         /* Read CAN data and show. */
 508:../src/can.c  **** //        api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX, &rx_dataframe);
 509:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX1, &rx_dataframe1);
 510:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX2, &rx_dataframe2);
 511:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX3, &rx_dataframe3);
 512:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX4, &rx_dataframe4);
 513:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX5, &rx_dataframe5);
 514:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX6, &rx_dataframe6);
 515:../src/can.c  **** 
 516:../src/can.c  ****         /* You can set BP here and check the received data in debugger. */
 517:../src/can.c  ****         R_BSP_NOP();
 518:../src/can.c  **** 
 519:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 520:../src/can.c  **** //            printf("Received CAN ID 0x%X, nr_frames_rx = %d.\n", rx_dataframe.id, nr_frames_rx);
 521:../src/can.c  ****         #endif
 522:../src/can.c  **** 
 523:../src/can.c  ****         if (api_status == R_CAN_MSGLOST)
 524:../src/can.c  ****         {
 525:../src/can.c  ****             #if BSP_CFG_IO_LIB_ENABLE
 526:../src/can.c  ****                 printf( "MSGLOST\n\n");
 527:../src/can.c  ****             #endif
 528:../src/can.c  ****             R_BSP_NOP();
 529:../src/can.c  ****         }
 530:../src/can.c  ****     }
 531:../src/can.c  **** 
 532:../src/can.c  ****     #if REMOTE_DEMO_ENABLE
 533:../src/can.c  ****     /* Previous remote reply succeeded? */
 534:../src/can.c  ****     if (CAN0_tx_remote_sentdata_flag)
 535:../src/can.c  ****     {
 536:../src/can.c  ****         CAN0_tx_remote_sentdata_flag = 0;
 537:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 538:../src/can.c  ****             printf( "Remote trig.\n");
 539:../src/can.c  ****         #endif
 540:../src/can.c  ****     }
 541:../src/can.c  **** 
 542:../src/can.c  ****     /* Set up remote reply if remote request came in. */
 543:../src/can.c  ****     if (CAN0_rx_remote_frame_flag == 1)
 544:../src/can.c  ****     {
 545:../src/can.c  ****         CAN0_rx_remote_frame_flag = 0;
 546:../src/can.c  ****         remote_frame.data[0]++;
 547:../src/can.c  **** 
 548:../src/can.c  ****         if (FRAME_ID_MODE == STD_ID_MODE )
 549:../src/can.c  ****         {
 550:../src/can.c  ****         	api_status |= R_CAN_TxSet(g_can_channel, g_mb_mode, CANBOX_REMOTE_TX, &remote_frame, DATA_
 551:../src/can.c  ****         }
 552:../src/can.c  ****         else
 553:../src/can.c  ****         {
 554:../src/can.c  ****         	api_status |= R_CAN_TxSetXid(g_can_channel, g_mb_mode, CANBOX_REMOTE_TX, &remote_frame, DA
 555:../src/can.c  ****         }
 556:../src/can.c  ****     }
 557:../src/can.c  ****     #endif
 558:../src/can.c  **** }/* end can_int_demo() */
 559:../src/can.c  **** #endif
 560:../src/can.c  **** 
 561:../src/can.c  **** /*****************************************************************************
 562:../src/can.c  **** Function name:  init_can_app
 563:../src/can.c  **** Parameters:     -
 564:../src/can.c  **** Returns:        -
 565:../src/can.c  **** Description:    Initialize CAN mailboxes, and setup the demo receive and trans-
 566:../src/can.c  ****                 mit dataframe variables. See top of file for demo description.
 567:../src/can.c  ****                 After startup, user calls to transmit demo frame done by SW1Func()
 568:../src/can.c  ****                 in file switches.c.
 569:../src/can.c  **** *****************************************************************************/
 570:../src/can.c  **** static uint32_t init_can_app(void)
 571:../src/can.c  **** {
 572:../src/can.c  ****     uint32_t    api_status = R_CAN_OK;
 573:../src/can.c  ****     uint8_t     i;
 574:../src/can.c  **** 
 575:../src/can.c  ****     can_state[0] = R_CAN_STATUS_ERROR_ACTIVE;
 576:../src/can.c  **** 
 577:../src/can.c  ****     /* Initialize status for all channels. */
 578:../src/can.c  ****     for (i = 0; i < NR_CAN_CHANNELS; i++)
 579:../src/can.c  ****     {
 580:../src/can.c  ****         error_bus_status[i] = R_CAN_STATUS_ERROR_ACTIVE;
 581:../src/can.c  ****         error_bus_status_prev[i] = R_CAN_STATUS_ERROR_ACTIVE;
 582:../src/can.c  ****     }
 583:../src/can.c  **** 
 584:../src/can.c  ****     /******** Init demo to receive data ********/
 585:../src/can.c  ****     /* Use API to set one CAN mailbox for demo receive. */
 586:../src/can.c  ****     /* Standard id. Choose value 0-0x07FF (2047). */
 587:../src/can.c  ****     if (FRAME_ID_MODE == STD_ID_MODE)
 588:../src/can.c  ****     {
 589:../src/can.c  **** //      api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX, RX_CANID_DEMO_INIT, DATA_FRAME);
 590:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX1, RX_CANID_DEMO_INIT1, DATA_FRAME);
 591:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX2, RX_CANID_DEMO_INIT2, DATA_FRAME);
 592:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX3, RX_CANID_DEMO_INIT3, DATA_FRAME);
 593:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX4, RX_CANID_DEMO_INIT4, DATA_FRAME);
 594:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX5, RX_CANID_DEMO_INIT5, DATA_FRAME);
 595:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX6, RX_CANID_DEMO_INIT6, DATA_FRAME);
 596:../src/can.c  **** 
 597:../src/can.c  ****         /* Mask for receive box.
 598:../src/can.c  ****          * 0x7FF = no mask. 0x7FD = mask bit 1, for example; If receive ID is set to 1, both ID 1 a
 599:../src/can.c  ****          * 0x00 = MASK ALL = receive all frames. */
 600:../src/can.c  **** //      R_CAN_RxSetMask(g_can_channel, CANBOX_RX, 0x7FF);
 601:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX1, 0x7FF);
 602:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX2, 0x7FF);
 603:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX3, 0x7FF);
 604:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX4, 0x7FF);
 605:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX5, 0x7FF);
 606:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX6, 0x7FF);
 607:../src/can.c  ****     }
 608:../src/can.c  ****     else
 609:../src/can.c  ****     {
 610:../src/can.c  **** //      api_status |= R_CAN_RxSetXid(g_can_channel, CANBOX_RX, RX_CANID_DEMO_INIT, DATA_FRAME);
 611:../src/can.c  ****         api_status |= R_CAN_RxSetXid(g_can_channel, CANBOX_RX1, RX_CANID_DEMO_INIT1, DATA_FRAME);
 612:../src/can.c  **** 
 613:../src/can.c  ****         /* Mask for receive box.
 614:../src/can.c  ****          * 0x1FFFFFFF = no mask. 0x1FFFFFFD = mask bit 1, for example; If receive ID is set to 1, b
 615:../src/can.c  ****            ID 1 and 3 should be received. */
 616:../src/can.c  ****         R_CAN_RxSetMask( g_can_channel, CANBOX_RX1, 0x1FFFFFFF);
 617:../src/can.c  ****     }
 618:../src/can.c  **** 
 619:../src/can.c  ****     /********Init. demo Tx dataframe RAM structure********
 620:../src/can.c  ****     Standard ID; choose value 0-0x07FF.
 621:../src/can.c  ****     Extended ID; choose value 0-0x1FFFFFFD. */
 622:../src/can.c  ****     tx_dataframe.id         = TX_CANID_DEMO_INIT;
 623:../src/can.c  ****     tx_dataframe.dlc        = 8;
 624:../src/can.c  ****     for (i = 0; i < 8; i++)
 625:../src/can.c  ****     {
 626:../src/can.c  ****         tx_dataframe.data[i]    = i;
 627:../src/can.c  ****     }
 628:../src/can.c  **** 
 629:../src/can.c  ****     #if REMOTE_DEMO_ENABLE
 630:../src/can.c  ****     /*************** Init. remote dataframe response **********************/
 631:../src/can.c  ****     remote_frame.id = REMOTE_TEST_ID;
 632:../src/can.c  **** 
 633:../src/can.c  ****     /* Length is specified by the remote request. */
 634:../src/can.c  **** 
 635:../src/can.c  ****     /* Some data.. */
 636:../src/can.c  ****     for (i = 0; i < 8; i++)
 637:../src/can.c  ****     {
 638:../src/can.c  ****         remote_frame.data[i] = i;
 639:../src/can.c  ****     }
 640:../src/can.c  **** 
 641:../src/can.c  ****     /* Prepare mailbox for Tx. */
 642:../src/can.c  ****     if (FRAME_ID_MODE == STD_ID_MODE)
 643:../src/can.c  ****     {
 644:../src/can.c  ****         R_CAN_RxSet(g_can_channel, CANBOX_REMOTE_RX, REMOTE_TEST_ID, REMOTE_FRAME);
 645:../src/can.c  ****     }
 646:../src/can.c  ****     else
 647:../src/can.c  ****     {
 648:../src/can.c  ****         R_CAN_RxSetXid(g_can_channel, CANBOX_REMOTE_RX, REMOTE_TEST_ID, REMOTE_FRAME);
 649:../src/can.c  ****     }
 650:../src/can.c  ****     #endif
 651:../src/can.c  ****     /***********************************************************************/
 652:../src/can.c  **** 
 653:../src/can.c  ****     /* Set frame buffer id so trace shows correct receive ID from start. */
 654:../src/can.c  **** //  rx_dataframe.id = RX_CANID_DEMO_INIT;
 655:../src/can.c  ****     rx_dataframe1.id = RX_CANID_DEMO_INIT1;
 656:../src/can.c  ****     rx_dataframe2.id = RX_CANID_DEMO_INIT2;
 657:../src/can.c  ****     rx_dataframe3.id = RX_CANID_DEMO_INIT3;
 658:../src/can.c  ****     rx_dataframe4.id = RX_CANID_DEMO_INIT4;
 659:../src/can.c  ****     rx_dataframe5.id = RX_CANID_DEMO_INIT5;
 660:../src/can.c  ****     rx_dataframe6.id = RX_CANID_DEMO_INIT6;
 661:../src/can.c  **** 
 662:../src/can.c  ****     app_err_nr |= APP_NO_ERR;
 663:../src/can.c  **** 
 664:../src/can.c  ****     return (api_status);
 665:../src/can.c  **** } /* end init_can_app */
 666:../src/can.c  **** 
 667:../src/can.c  **** /*****************************************************************************
 668:../src/can.c  **** Function Name:  check_can_errors
 669:../src/can.c  **** Parameters:     -
 670:../src/can.c  **** Returns:        -
 671:../src/can.c  **** Description:    Check for all possible errors, in app and peripheral. Add
 672:../src/can.c  ****                 checking for your app here.
 673:../src/can.c  **** *****************************************************************************/
 674:../src/can.c  **** static void check_can_errors(void)
 675:../src/can.c  **** {
 676:../src/can.c  ****     /* Error passive or more? */
 677:../src/can.c  ****     handle_can_bus_state(g_can_channel);
 678:../src/can.c  **** 
 679:../src/can.c  ****     if (app_err_nr)
 680:../src/can.c  ****     {
 681:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 682:../src/can.c  ****             printf("Check CAN errors. app_err_nr = %d\n", app_err_nr);
 683:../src/can.c  ****         #endif
 684:../src/can.c  **** 
 685:../src/can.c  ****         app_err_nr = APP_NO_ERR;
 686:../src/can.c  **** 
 687:../src/can.c  ****         /* Show error to user */
 688:../src/can.c  ****         /* RESET ERRORs with SW1. */
 689:../src/can.c  **** //        LED3 = LED_ON;  //RED LED
 690:../src/can.c  ****         LED1 = LED_ON;  //AP change
 691:../src/can.c  ****     }
 692:../src/can.c  **** }/* end check_can_errors() */
 693:../src/can.c  **** 
 694:../src/can.c  **** /*****************************************************************************
 695:../src/can.c  **** Function name:  handle_can_bus_state()
 696:../src/can.c  **** Parameters:     Bus number
 697:../src/can.c  **** Returns:        -
 698:../src/can.c  **** Description:    Check CAN peripheral bus state.
 699:../src/can.c  **** *****************************************************************************/
 700:../src/can.c  **** static void handle_can_bus_state(uint8_t ch_nr)
 701:../src/can.c  **** {
 702:../src/can.c  ****     /* Has the status register reached error passive or more? */
 703:../src/can.c  ****     if (ch_nr < NR_CAN_CHANNELS)
 704:../src/can.c  ****     {
 705:../src/can.c  ****         error_bus_status[ch_nr] = R_CAN_CheckErr(ch_nr);
 706:../src/can.c  ****     }
 707:../src/can.c  ****     else
 708:../src/can.c  ****     {
 709:../src/can.c  ****         return;
 710:../src/can.c  ****     }
 711:../src/can.c  **** 
 712:../src/can.c  ****     /* Tell user if CAN bus status changed.
 713:../src/can.c  ****        All Status bits are read only. */
 714:../src/can.c  ****     if (error_bus_status[ch_nr] != error_bus_status_prev[ch_nr])
 715:../src/can.c  ****     {
 716:../src/can.c  ****         switch (error_bus_status[ch_nr])
 717:../src/can.c  ****         {
 718:../src/can.c  ****             /* Error Active. */
 719:../src/can.c  ****             case R_CAN_STATUS_ERROR_ACTIVE:
 720:../src/can.c  ****                 /* Only report if we recovered from Error Passive or Bus Off. */
 721:../src/can.c  ****                 if (error_bus_status_prev[ch_nr] > R_CAN_STATUS_ERROR_ACTIVE)
 722:../src/can.c  ****                 {
 723:../src/can.c  ****                     #if BSP_CFG_IO_LIB_ENABLE
 724:../src/can.c  ****                         printf("CAN channel %d R_CAN_STATUS_ERROR_ACTIVE\n\n", ch_nr);
 725:../src/can.c  ****                     #endif
 726:../src/can.c  ****                 }
 727:../src/can.c  ****                 /* Restart if returned from Bus Off. */
 728:../src/can.c  ****                 if (error_bus_status_prev[ch_nr] == R_CAN_STATUS_BUSOFF)
 729:../src/can.c  ****                 {
 730:../src/can.c  ****                     #if BSP_CFG_IO_LIB_ENABLE
 731:../src/can.c  ****                         printf("CAN channel %d returned from Bus Off. REINIT CAN PERIPHERAL.\n\n", 
 732:../src/can.c  ****                     #endif
 733:../src/can.c  **** 
 734:../src/can.c  ****                     /* Restart CAN */
 735:../src/can.c  ****                     #if USE_CAN_POLL
 736:../src/can.c  ****                         if (R_CAN_Create(g_can_channel, g_mb_mode, CAN0_bitrate_cfg, NULL, NULL, NU
 737:../src/can.c  ****                     #else
 738:../src/can.c  ****                         if (R_CAN_Create(g_can_channel, g_mb_mode, CAN0_bitrate_cfg, my_can_tx0_cal
 739:../src/can.c  ****                     #endif
 740:../src/can.c  **** 
 741:../src/can.c  ****                     /* Restart CAN demos even if only one channel failed. */
 742:../src/can.c  ****                     init_can_app();
 743:../src/can.c  ****                 }
 744:../src/can.c  ****                 break;
 745:../src/can.c  **** 
 746:../src/can.c  ****             /* Error Passive. */
 747:../src/can.c  ****             case R_CAN_STATUS_ERROR_PASSIVE:
 748:../src/can.c  ****                 #if BSP_CFG_IO_LIB_ENABLE
 749:../src/can.c  ****                     printf("CAN channel %d R_CAN_STATUS_ERROR_PASSIVE\n\n", ch_nr);
 750:../src/can.c  ****                 #endif
 751:../src/can.c  ****                 break;
 752:../src/can.c  **** 
 753:../src/can.c  ****             case R_CAN_STATUS_BUSOFF:
 754:../src/can.c  ****             default:
 755:../src/can.c  ****                 nr_times_reached_busoff[ch_nr]++;
 756:../src/can.c  ****                 #if BSP_CFG_IO_LIB_ENABLE
 757:../src/can.c  ****                     printf("CAN channel %d R_CAN_STATUS_BUSOFF\n\n", ch_nr);
 758:../src/can.c  ****                 #endif
 759:../src/can.c  ****                 break;
 760:../src/can.c  ****         }
 761:../src/can.c  ****         error_bus_status_prev[ch_nr] = error_bus_status[ch_nr];
 762:../src/can.c  ****     }
 763:../src/can.c  **** }/* end handle_can_bus_state() */
 764:../src/can.c  **** 
 765:../src/can.c  **** /*******************************************************************************
 766:../src/can.c  **** Function name:  reset_all_errors()
 767:../src/can.c  **** Description:    Reset all types of errors, application and CAN peripeheral errors.
 768:../src/can.c  **** Parameters:     g_can_channel   Channel number to reset.
 769:../src/can.c  **** Return value:   CAN API code
 770:../src/can.c  **** *******************************************************************************/
 771:../src/can.c  **** uint32_t reset_all_errors(uint8_t g_can_channel)
 772:../src/can.c  **** {
 773:../src/can.c  ****     uint32_t status = 0;
 774:../src/can.c  **** 
 775:../src/can.c  ****     /* Reset errors */
 776:../src/can.c  ****     app_err_nr = APP_NO_ERR;
 777:../src/can.c  **** 
 778:../src/can.c  ****     error_bus_status[0] = 0;
 779:../src/can.c  ****     error_bus_status[1] = 0;
 780:../src/can.c  **** 
 781:../src/can.c  ****     /* You can choose to not reset error_bus_status_prev; if there was an error,
 782:../src/can.c  ****     keep info to signal recovery */
 783:../src/can.c  ****     error_bus_status_prev[0] = 0;
 784:../src/can.c  ****     error_bus_status_prev[1] = 0;
 785:../src/can.c  **** 
 786:../src/can.c  ****     nr_times_reached_busoff[0] = 0;
 787:../src/can.c  ****     nr_times_reached_busoff[1] = 0;
 788:../src/can.c  **** 
 789:../src/can.c  ****     /* Reset Error Judge Factor and Error Code registers */
 790:../src/can.c  ****     CAN0.EIFR.BYTE = 0;
 791:../src/can.c  **** 
 792:../src/can.c  ****     /* Reset CAN0 Error Code Store Register (ECSR). */
 793:../src/can.c  ****     CAN0.ECSR.BYTE = 0;
 794:../src/can.c  **** 
 795:../src/can.c  ****     /* Reset CAN0 Error Counters. */
 796:../src/can.c  ****     CAN0.RECR = 0;
 797:../src/can.c  ****     CAN0.TECR = 0;
 798:../src/can.c  **** 
 799:../src/can.c  ****     return (status);
 800:../src/can.c  **** }/* end reset_all_errors() */
 801:../src/can.c  **** 
 802:../src/can.c  **** /******************************************************************************
 803:../src/can.c  **** Function name:      test_leds
 804:../src/can.c  **** Parameters:         -
 805:../src/can.c  **** Return value:       -
 806:../src/can.c  **** Description:        Blink the LEDs
 807:../src/can.c  **** ******************************************************************************/
 808:../src/can.c  **** static void test_leds(uint32_t nr_led_flashes)
 809:../src/can.c  **** {
  10                             		.loc 1 809 1 view -0
  11                             		.loc 1 809 1 is_stmt 0 view .LVU1
  12 0000 60 40                   		sub	#4, r0
  13                             	.LCFI0:
 810:../src/can.c  ****     uint32_t    i;
  14                             		.loc 1 810 5 is_stmt 1 view .LVU2
 811:../src/can.c  ****     uint32_t    j = LED_DELAY;
  15                             		.loc 1 811 5 view .LVU3
  16                             	.LVL1:
 812:../src/can.c  ****     uint8_t     led_time_sequence[] = {LED_ON, LED_OFF, LED_OFF, LED_OFF};
  17                             		.loc 1 812 5 view .LVU4
  18                             		.loc 1 812 17 is_stmt 0 view .LVU5
  19 0002 F8 04 01                		mov.B	#1, [r0]
  20 0005 3C 01 00                		mov.B	#0, 1[r0]
  21 0008 3C 02 00                		mov.B	#0, 2[r0]
  22 000b 3C 03 00                		mov.B	#0, 3[r0]
 813:../src/can.c  **** 
 814:../src/can.c  ****     LED0 = LED_ON;
  23                             		.loc 1 814 5 is_stmt 1 view .LVU6
  24                             		.loc 1 814 10 is_stmt 0 view .LVU7
  25 000e FB 5E 09 C0 08          		mov.L	#0x8c009, r5
  26 0013 CD 54 20                		mov.B	32[r5], r4
  27 0016 78 54                   		bset	#5, r4
  28 0018 C7 54 20                		mov.B	r4, 32[r5]
 815:../src/can.c  ****     LED1 = LED_ON;
  29                             		.loc 1 815 5 is_stmt 1 view .LVU8
  30                             		.loc 1 815 10 is_stmt 0 view .LVU9
  31 001b CD 54 20                		mov.B	32[r5], r4
  32 001e 78 64                   		bset	#6, r4
  33 0020 C7 54 20                		mov.B	r4, 32[r5]
 816:../src/can.c  **** 
 817:../src/can.c  ****     for (i = 0; i < nr_led_flashes; i++)
  34                             		.loc 1 817 5 is_stmt 1 view .LVU10
  35                             	.LVL2:
  36                             		.loc 1 817 12 is_stmt 0 view .LVU11
  37 0023 66 03                   		mov.L	#0, r3
  38                             		.loc 1 817 5 view .LVU12
  39 0025 2E 3A                   		bra	.L2
  40                             	.LVL3:
  41                             	.L4:
 818:../src/can.c  ****     {
 819:../src/can.c  ****         while(j--)
  42                             		.loc 1 819 16 view .LVU13
  43 0027 EF 45                   		mov.L	r4, r5
  44                             	.LVL4:
  45                             	.L3:
 820:../src/can.c  ****         {
 821:../src/can.c  ****             ;
  46                             		.loc 1 821 13 is_stmt 1 discriminator 1 view .LVU14
 819:../src/can.c  ****         {
  47                             		.loc 1 819 16 is_stmt 0 discriminator 1 view .LVU15
  48 0029 71 54 FF                		add	#-1, r5, r4
  49                             	.LVL5:
 819:../src/can.c  ****         {
  50                             		.loc 1 819 14 discriminator 1 view .LVU16
  51 002c 61 05                   		cmp	#0, r5
  52 002e 21 F9                   		bne	.L4
 822:../src/can.c  ****         }
 823:../src/can.c  ****         j = LED_DELAY;
  53                             		.loc 1 823 9 is_stmt 1 discriminator 2 view .LVU17
  54                             	.LVL6:
 824:../src/can.c  **** 
 825:../src/can.c  ****         LED0 = led_time_sequence[i%4];
  55                             		.loc 1 825 9 discriminator 2 view .LVU18
  56                             		.loc 1 825 35 is_stmt 0 discriminator 2 view .LVU19
  57 0030 66 35                   		mov.L	#3, r5
  58 0032 53 35                   		and	r3, r5
  59                             		.loc 1 825 33 discriminator 2 view .LVU20
  60 0034 FE 45 02                		mov.B	[r5,r0], r2
  61                             		.loc 1 825 14 discriminator 2 view .LVU21
  62 0037 FB 5E 09 C0 08          		mov.L	#0x8c009, r5
  63 003c CD 54 20                		mov.B	32[r5], r4
  64 003f FD 74 C2 01             		tst	#1, r2
  65 0043 FD E5 14                		bmne	#5, r4
  66 0046 C7 54 20                		mov.B	r4, 32[r5]
 826:../src/can.c  ****         LED1 = led_time_sequence[(i + 1)%4];
  67                             		.loc 1 826 9 is_stmt 1 discriminator 2 view .LVU22
  68                             		.loc 1 826 37 is_stmt 0 discriminator 2 view .LVU23
  69 0049 62 13                   		add	#1, r3
  70                             	.LVL7:
  71                             		.loc 1 826 41 discriminator 2 view .LVU24
  72 004b 66 34                   		mov.L	#3, r4
  73 004d 53 34                   		and	r3, r4
  74                             		.loc 1 826 33 discriminator 2 view .LVU25
  75 004f FE 44 02                		mov.B	[r4,r0], r2
  76                             		.loc 1 826 14 discriminator 2 view .LVU26
  77 0052 CD 54 20                		mov.B	32[r5], r4
  78 0055 FD 74 C2 01             		tst	#1, r2
  79 0059 FD E6 14                		bmne	#6, r4
  80 005c C7 54 20                		mov.B	r4, 32[r5]
  81                             	.LVL8:
  82                             	.L2:
 817:../src/can.c  ****     {
  83                             		.loc 1 817 5 discriminator 1 view .LVU27
  84 005f 47 13                   		cmp	r1, r3
  85 0061 22 09                   		bgeu	.L7
  86 0063 FB 5E 00 00 20          		mov.L	#0x200000, r5
  87 0068 2E C1                   		bra	.L3
  88                             	.L7:
 827:../src/can.c  ****     }
 828:../src/can.c  **** 
 829:../src/can.c  ****     LED0 = LED_OFF;
  89                             		.loc 1 829 5 is_stmt 1 view .LVU28
  90                             		.loc 1 829 10 is_stmt 0 view .LVU29
  91 006a FB 5E 09 C0 08          		mov.L	#0x8c009, r5
  92 006f CD 54 20                		mov.B	32[r5], r4
  93 0072 7A 54                   		bclr	#5, r4
  94 0074 C7 54 20                		mov.B	r4, 32[r5]
 830:../src/can.c  ****     LED1 = LED_OFF;
  95                             		.loc 1 830 5 is_stmt 1 view .LVU30
  96                             		.loc 1 830 10 is_stmt 0 view .LVU31
  97 0077 CD 54 20                		mov.B	32[r5], r4
  98 007a 7A 64                   		bclr	#6, r4
  99 007c C7 54 20                		mov.B	r4, 32[r5]
 831:../src/can.c  **** 
 832:../src/can.c  **** } /* end test_leds() */
 100                             		.loc 1 832 1 view .LVU32
 101 007f 67 01                   		rtsd	#4
 102                             	.LFE10:
 104                             		.section	.text.my_can_rx0_callback,"ax",@progbits
 106                             	_my_can_rx0_callback:
 107                             	.LFB12:
 833:../src/can.c  **** 
 834:../src/can.c  **** /*******************************************************************************
 835:../src/can.c  **** 
 836:../src/can.c  **** CAN INTERRRUPTS
 837:../src/can.c  **** Interrupts are duplicated for each CAN channel used except for the Error
 838:../src/can.c  **** interrupt which handles all channels in a group.
 839:../src/can.c  **** Vectors are set according to the channel.
 840:../src/can.c  **** 
 841:../src/can.c  **** *******************************************************************************/
 842:../src/can.c  **** #if !USE_CAN_POLL
 843:../src/can.c  **** /*****************************************************************************
 844:../src/can.c  **** Name:CAN ISRs
 845:../src/can.c  **** Parameters:-
 846:../src/can.c  **** Returns:-
 847:../src/can.c  **** Description:CAN interrupt routine examples.
 848:../src/can.c  **** *****************************************************************************/
 849:../src/can.c  **** /*****************************************************************************
 850:../src/can.c  **** Function Name:  my_can_tx0_callback
 851:../src/can.c  **** Parameters:     -
 852:../src/can.c  **** Returns:        -
 853:../src/can.c  **** Description:    CAN0 Transmit interrupt.
 854:../src/can.c  ****                 Check which mailbox transmitted data and process it.
 855:../src/can.c  **** *****************************************************************************/
 856:../src/can.c  **** static void my_can_tx0_callback(void)
 857:../src/can.c  **** {
 858:../src/can.c  ****     uint32_t api_status = R_CAN_OK;
 859:../src/can.c  **** 
 860:../src/can.c  ****     api_status = R_CAN_TxCheck(CH_1, CANBOX_TX);
 861:../src/can.c  ****     if (api_status == R_CAN_OK)
 862:../src/can.c  ****     {
 863:../src/can.c  ****         CAN0_tx_sentdata_flag = 1;
 864:../src/can.c  ****     }
 865:../src/can.c  **** 
 866:../src/can.c  ****     #if REMOTE_DEMO_ENABLE
 867:../src/can.c  ****     api_status = R_CAN_TxCheck(CH_0, CANBOX_REMOTE_TX);
 868:../src/can.c  ****     if (api_status == R_CAN_OK)
 869:../src/can.c  ****         CAN0_tx_remote_sentdata_flag = 1;
 870:../src/can.c  ****     #endif
 871:../src/can.c  **** 
 872:../src/can.c  ****     /* Use mailbox search reg. Should be faster than above if a lot of mailboxes to check.
 873:../src/can.c  ****     Not verified. */
 874:../src/can.c  **** }/* end can_tx0_callback() */
 875:../src/can.c  **** 
 876:../src/can.c  **** /*****************************************************************************
 877:../src/can.c  **** Function Name:  my_can_rx0_callback
 878:../src/can.c  **** Parameters:     -
 879:../src/can.c  **** Returns:        -
 880:../src/can.c  **** Description:    CAN0 Receive interrupt. Check which mailbox received data and process it.
 881:../src/can.c  **** *****************************************************************************/
 882:../src/can.c  **** static void my_can_rx0_callback(void)
 883:../src/can.c  **** {
 108                             		.loc 1 883 1 is_stmt 1 view -0
 884:../src/can.c  ****     uint32_t api_status = R_CAN_OK;
 109                             		.loc 1 884 5 view .LVU34
 110                             	.LVL9:
 885:../src/can.c  **** 
 886:../src/can.c  ****     if (api_status == R_CAN_OK) /* So compiler doesn't complain when not using remote frames. */
 111                             		.loc 1 886 5 view .LVU35
 887:../src/can.c  ****     {
 888:../src/can.c  ****         CAN0_rx_newdata_flag = 1;
 112                             		.loc 1 888 9 view .LVU36
 113                             		.loc 1 888 30 is_stmt 0 view .LVU37
 114 0000 FB 52 00 00 00 00       		mov.L	#_CAN0_rx_newdata_flag, r5
 115 0006 F8 56 01                		mov.L	#1, [r5]
 889:../src/can.c  ****     }
 890:../src/can.c  **** 
 891:../src/can.c  ****     #if REMOTE_DEMO_ENABLE
 892:../src/can.c  ****     api_status = R_CAN_RxPoll(CH_0, CANBOX_REMOTE_RX);
 893:../src/can.c  ****     if (api_status == R_CAN_OK)
 894:../src/can.c  ****     {
 895:../src/can.c  ****         /* REMOTE_FRAME FRAME REQUEST RECEIVED */
 896:../src/can.c  ****         /* Do not set BP on the next line to check for Remote frame. By the time you
 897:../src/can.c  ****         continue, the recsucc flag will already have changed to be a trmsucc flag in
 898:../src/can.c  ****         the CAN status reg. */
 899:../src/can.c  **** 
 900:../src/can.c  ****         /* Reset of the receive/transmit flag in the MCTL register will be done by
 901:../src/can.c  ****         set_remote_reply_std_CAN0(). */
 902:../src/can.c  **** 
 903:../src/can.c  ****         /* Tell application. */
 904:../src/can.c  ****         CAN0_rx_remote_frame_flag = 1;
 905:../src/can.c  **** 
 906:../src/can.c  ****         remote_frame.dlc = (uint8_t)(CAN0.MB[CANBOX_REMOTE_RX].DLC);
 907:../src/can.c  **** 
 908:../src/can.c  ****         /* Reset NEWDATA flag since we won't be reading the mailbox. */
 909:../src/can.c  ****         CAN0.MCTL[CANBOX_REMOTE_RX].BIT.RX.NEWDATA = 0;
 910:../src/can.c  **** 
 911:../src/can.c  ****         /* Confirmation of receival of remote flag is done by remote frame being sent,
 912:../src/can.c  ****         so no need flag application we received remote request. */
 913:../src/can.c  ****         CAN0_rx_newdata_flag = 0;
 914:../src/can.c  ****     }
 915:../src/can.c  ****     #endif
 916:../src/can.c  **** 
 917:../src/can.c  ****     /* Use mailbox search reg. Should be faster if a lot of mailboxes to check.
 918:../src/can.c  ****     Not verified. */
 919:../src/can.c  **** }/* end my_can_rx0_callback() */
 116                             		.loc 1 919 1 view .LVU38
 117 0009 02                      		rts
 118                             	.LFE12:
 120                             		.section	.text.my_can_err0_callback,"ax",@progbits
 122                             	_my_can_err0_callback:
 123                             	.LFB13:
 920:../src/can.c  **** 
 921:../src/can.c  **** /*****************************************************************************
 922:../src/can.c  **** Function Name:  my_can_err0_callback
 923:../src/can.c  **** Parameters:     -
 924:../src/can.c  **** Returns:        -
 925:../src/can.c  **** Description:    CAN0 Error interrupt.
 926:../src/can.c  **** *****************************************************************************/
 927:../src/can.c  **** static void my_can_err0_callback(void)
 928:../src/can.c  **** {
 124                             		.loc 1 928 1 is_stmt 1 view -0
 929:../src/can.c  ****     /* Error interrupt can have multiple sources. Check interrupt flags to id source. */
 930:../src/can.c  ****     if (IS(CAN0, ERS0))
 125                             		.loc 1 930 5 view .LVU40
 126                             		.loc 1 930 9 is_stmt 0 view .LVU41
 127 0000 FB 5E 00 70 08          		mov.L	#0x87000, r5
 128 0005 EE 55 80 01             		mov.L	1536[r5], r5
 129                             		.loc 1 930 8 view .LVU42
 130 0009 FD 74 C5 01             		tst	#1, r5
 131 000d 20 12                   		beq	.L9
 931:../src/can.c  ****     {
 932:../src/can.c  ****         #if ERROR_DIAG
 933:../src/can.c  ****             uint8_t         err_int_factor, errcode_store;
 934:../src/can.c  ****             static uint8_t  err_int_factor_accumulate, errcode_store_accumulate;
 935:../src/can.c  **** 
 936:../src/can.c  **** //            LED3 = LED_ON;
 937:../src/can.c  **** 
 938:../src/can.c  ****             /* Cause identification. */
 939:../src/can.c  ****             err_int_factor = CAN0.EIFR.BYTE;
 940:../src/can.c  ****             err_int_factor_accumulate |= CAN0.EIFR.BYTE;
 941:../src/can.c  ****             errcode_store = CAN0.ECSR.BYTE;
 942:../src/can.c  ****             errcode_store_accumulate |= CAN0.ECSR.BYTE;
 943:../src/can.c  **** 
 944:../src/can.c  ****             /* Clear EIFR and ECSR. Do a byte-write to avoid read-modify-write with HW writing anot
 945:../src/can.c  ****              * "When a single bit is set to 0 by a program, do not use the logic operation instruct
 946:../src/can.c  ****              * instruction (MOV) to ensure that only the specified bit is set to 0 and the other bi
 947:../src/can.c  ****              * has no effect to these bit values.)" */
 948:../src/can.c  ****             CAN0.EIFR.BYTE = 0;
 949:../src/can.c  ****             CAN0.ECSR.BYTE = 0;
 950:../src/can.c  **** 
 951:../src/can.c  ****             #if BSP_CFG_IO_LIB_ENABLE
 952:../src/can.c  ****                 printf("CAN0 error diag: \nerr_int_factor 0x%X, accumulated value 0x%X\n", err_int_
 953:../src/can.c  ****                 printf("errcode_store 0x%X, accumulated value 0x%X\n", errcode_store, errcode_store
 954:../src/can.c  ****             #endif
 955:../src/can.c  ****         #endif
 956:../src/can.c  **** 
 957:../src/can.c  ****         /* Set BP here to catch cause. */
 958:../src/can.c  ****         R_BSP_NOP();
 132                             		.loc 1 958 9 is_stmt 1 view .LVU43
 133                             	 ; 958 "../src/can.c" 1
 134 000f 03                      		nop
 135                             	 ; 0 "" 2
 959:../src/can.c  **** 
 960:../src/can.c  ****         /* Clear interrupt. */
 961:../src/can.c  ****         CLR(CAN0, ERS0) = 1;
 136                             		.loc 1 961 9 view .LVU44
 137                             		.loc 1 961 25 is_stmt 0 view .LVU45
 138 0010 FB 5E 00 70 08          		mov.L	#0x87000, r5
 139 0015 EE 54 A0 01             		mov.L	1664[r5], r4
 140 0019 78 04                   		bset	#0, r4
 141 001b EB 54 A0 01             		mov.L	r4, 1664[r5]
 142                             	.L9:
 962:../src/can.c  ****     }
 963:../src/can.c  **** }/* end my_can_err0_callback() */
 143                             		.loc 1 963 1 view .LVU46
 144 001f 02                      		rts
 145                             	.LFE13:
 147                             		.section	.text.demo_output_ports_configure,"ax",@progbits
 149                             	_demo_output_ports_configure:
 150                             	.LFB15:
 964:../src/can.c  **** 
 965:../src/can.c  **** #ifdef CAN1
 966:../src/can.c  **** /*****************************************************************************
 967:../src/can.c  **** Function Name:  my_can_err1_callback
 968:../src/can.c  **** Parameters:     -
 969:../src/can.c  **** Returns:        -
 970:../src/can.c  **** Description:    CAN1 Error interrupt.
 971:../src/can.c  **** *****************************************************************************/
 972:../src/can.c  **** void my_can_err1_callback(void)
 973:../src/can.c  **** {
 974:../src/can.c  ****     /* Error interrupt can have multiple sources. Check interrupt flags to id source. */
 975:../src/can.c  ****     if (IS(CAN1, ERS1))
 976:../src/can.c  ****     {
 977:../src/can.c  ****         #if ERROR_DIAG
 978:../src/can.c  ****             uint8_t         err_int_factor, errcode_store;
 979:../src/can.c  ****             static uint8_t  err_int_factor_accumulate, errcode_store_accumulate;
 980:../src/can.c  **** 
 981:../src/can.c  **** //            LED3 = LED_ON;
 982:../src/can.c  **** 
 983:../src/can.c  ****             /* Cause identification. */
 984:../src/can.c  ****             err_int_factor = CAN1.EIFR.BYTE;
 985:../src/can.c  ****             err_int_factor_accumulate |= CAN1.EIFR.BYTE;
 986:../src/can.c  ****             errcode_store = CAN1.ECSR.BYTE;
 987:../src/can.c  ****             errcode_store_accumulate |= CAN1.ECSR.BYTE;
 988:../src/can.c  **** 
 989:../src/can.c  ****             /* Clear EIFR and ECSR. Do a byte-write to avoid read-modify-write with HW writing anot
 990:../src/can.c  ****              * "When a single bit is set to 0 by a program, do not use the logic operation instruct
 991:../src/can.c  ****              * instruction (MOV) to ensure that only the specified bit is set to 0 and the other bi
 992:../src/can.c  ****              * has no effect to these bit values.)" */
 993:../src/can.c  ****             CAN1.EIFR.BYTE = 0;
 994:../src/can.c  ****             CAN1.ECSR.BYTE = 0;
 995:../src/can.c  **** 
 996:../src/can.c  ****             #if BSP_CFG_IO_LIB_ENABLE
 997:../src/can.c  ****                 printf("CAN1 error diag: \nerr_int_factor 0x%X, accumulated value 0x%X\n", err_int_
 998:../src/can.c  ****                 printf("errcode_store 0x%X, accumulated value 0x%X\n", errcode_store, errcode_store
 999:../src/can.c  ****             #endif
1000:../src/can.c  ****         #endif //ERROR_DIAG
1001:../src/can.c  **** 
1002:../src/can.c  ****         /* Set BP here to catch cause. */
1003:../src/can.c  ****         R_BSP_NOP();
1004:../src/can.c  **** 
1005:../src/can.c  ****         /* Clear interrupt. */
1006:../src/can.c  ****         CLR(CAN1, ERS1) = 1;
1007:../src/can.c  ****     }
1008:../src/can.c  **** }/* end my_can_err1_callback() */
1009:../src/can.c  **** #endif
1010:../src/can.c  **** 
1011:../src/can.c  **** #if(0)
1012:../src/can.c  **** #ifdef CAN2
1013:../src/can.c  **** /*****************************************************************************
1014:../src/can.c  **** Function Name:  my_can_err2_callback
1015:../src/can.c  **** Parameters:     -
1016:../src/can.c  **** Returns:        -
1017:../src/can.c  **** Description:    CAN2 Error interrupt.
1018:../src/can.c  **** *****************************************************************************/
1019:../src/can.c  **** static void my_can_err2_callback(void)
1020:../src/can.c  **** {
1021:../src/can.c  ****     /* Error interrupt can have multiple sources. Check interrupt flags to id source. */
1022:../src/can.c  ****     if (IS(CAN2, ERS2))
1023:../src/can.c  ****     {
1024:../src/can.c  ****         #if ERROR_DIAG
1025:../src/can.c  ****             uint8_t         err_int_factor, errcode_store;
1026:../src/can.c  ****             static uint8_t  err_int_factor_accumulate, errcode_store_accumulate;
1027:../src/can.c  **** 
1028:../src/can.c  ****             LED3 = LED_ON;
1029:../src/can.c  **** 
1030:../src/can.c  ****             /* Cause identification. */
1031:../src/can.c  ****             err_int_factor = CAN2.EIFR.BYTE;
1032:../src/can.c  ****             err_int_factor_accumulate |= CAN2.EIFR.BYTE;
1033:../src/can.c  ****             errcode_store = CAN2.ECSR.BYTE;
1034:../src/can.c  ****             errcode_store_accumulate |= CAN2.ECSR.BYTE;
1035:../src/can.c  **** 
1036:../src/can.c  ****             /* Clear EIFR and ECSR. Do a byte-write to avoid read-modify-write with HW writing anot
1037:../src/can.c  ****              * "When a single bit is set to 0 by a program, do not use the logic operation instruct
1038:../src/can.c  ****              * instruction (MOV) to ensure that only the specified bit is set to 0 and the other bi
1039:../src/can.c  ****              * has no effect to these bit values.)" */
1040:../src/can.c  ****             CAN2.EIFR.BYTE = 0;
1041:../src/can.c  ****             CAN2.ECSR.BYTE = 0;
1042:../src/can.c  **** 
1043:../src/can.c  ****             #if BSP_CFG_IO_LIB_ENABLE
1044:../src/can.c  ****                 printf("CAN2 error diag: \nerr_int_factor 0x%X, accumulated value 0x%X\n", err_int_
1045:../src/can.c  ****                 printf("errcode_store 0x%X, accumulated value 0x%X\n", errcode_store, errcode_store
1046:../src/can.c  ****             #endif
1047:../src/can.c  ****         #endif //ERROR_DIAG
1048:../src/can.c  **** 
1049:../src/can.c  ****         /* Set BP here to catch cause. */
1050:../src/can.c  ****         R_BSP_NOP();
1051:../src/can.c  **** 
1052:../src/can.c  ****         /* Clear interrupt. */
1053:../src/can.c  ****         CLR(CAN2, ERS2) = 1;
1054:../src/can.c  ****     }
1055:../src/can.c  **** }/* end my_can_err2_callback() */
1056:../src/can.c  **** #endif
1057:../src/can.c  **** #endif
1058:../src/can.c  **** 
1059:../src/can.c  **** #endif  //USE_CAN_POLL
1060:../src/can.c  **** 
1061:../src/can.c  **** #ifdef __cplusplus
1062:../src/can.c  **** void abort(void)
1063:../src/can.c  **** {
1064:../src/can.c  **** }
1065:../src/can.c  **** #endif
1066:../src/can.c  **** 
1067:../src/can.c  **** /**************************************************************************************************
1068:../src/can.c  **** * Function name: output_ports_configure
1069:../src/can.c  **** * Description  : Configures the port and pin direction settings, and sets the pin outputs to a safe
1070:../src/can.c  **** * Arguments    : none
1071:../src/can.c  **** * Return value : none
1072:../src/can.c  **** ***************************************************************************************************
1073:../src/can.c  **** static void demo_output_ports_configure(void)
1074:../src/can.c  **** {
 151                             		.loc 1 1074 1 is_stmt 1 view -0
1075:../src/can.c  ****     /* Enable LEDs. */
1076:../src/can.c  ****     /* Start with LEDs off. */
1077:../src/can.c  ****     LED0 = LED_OFF;
 152                             		.loc 1 1077 5 view .LVU48
 153                             		.loc 1 1077 10 is_stmt 0 view .LVU49
 154 0000 FB 5E 09 C0 08          		mov.L	#0x8c009, r5
 155 0005 CD 54 20                		mov.B	32[r5], r4
 156 0008 7A 54                   		bclr	#5, r4
 157 000a C7 54 20                		mov.B	r4, 32[r5]
1078:../src/can.c  ****     LED1 = LED_OFF;
 158                             		.loc 1 1078 5 is_stmt 1 view .LVU50
 159                             		.loc 1 1078 10 is_stmt 0 view .LVU51
 160 000d CD 54 20                		mov.B	32[r5], r4
 161 0010 7A 64                   		bclr	#6, r4
 162 0012 C7 54 20                		mov.B	r4, 32[r5]
1079:../src/can.c  **** 
1080:../src/can.c  ****     /* Set LED pins as outputs. */
1081:../src/can.c  ****     LED0_PDR = 1;
 163                             		.loc 1 1081 5 is_stmt 1 view .LVU52
 164                             		.loc 1 1081 14 is_stmt 0 view .LVU53
 165 0015 CC 54                   		mov.B	[r5], r4
 166 0017 78 54                   		bset	#5, r4
 167 0019 C3 54                   		mov.B	r4, [r5]
1082:../src/can.c  ****     LED1_PDR = 1;
 168                             		.loc 1 1082 5 is_stmt 1 view .LVU54
 169                             		.loc 1 1082 14 is_stmt 0 view .LVU55
 170 001b CC 54                   		mov.B	[r5], r4
 171 001d 78 64                   		bset	#6, r4
 172 001f C3 54                   		mov.B	r4, [r5]
1083:../src/can.c  **** 
1084:../src/can.c  ****     /* Enable switches. */
1085:../src/can.c  ****     /* Set pins as inputs. */
1086:../src/can.c  **** //    SW1_PDR = 0;
1087:../src/can.c  **** //    SW2_PDR = 0;
1088:../src/can.c  **** //    SW3_PDR = 0;
1089:../src/can.c  **** 
1090:../src/can.c  ****     /* Set port mode registers for switches. */
1091:../src/can.c  **** //    SW1_PMR = 0;
1092:../src/can.c  **** //    SW2_PMR = 0;
1093:../src/can.c  **** //    SW3_PMR = 0;
1094:../src/can.c  **** }
 173                             		.loc 1 1094 1 view .LVU56
 174 0021 02                      		rts
 175                             	.LFE15:
 177                             		.section	.text.my_can_tx0_callback,"ax",@progbits
 179                             	_my_can_tx0_callback:
 180                             	.LFB11:
 857:../src/can.c  ****     uint32_t api_status = R_CAN_OK;
 181                             		.loc 1 857 1 is_stmt 1 view -0
 858:../src/can.c  **** 
 182                             		.loc 1 858 5 view .LVU58
 183                             	.LVL10:
 860:../src/can.c  ****     if (api_status == R_CAN_OK)
 184                             		.loc 1 860 5 view .LVU59
 860:../src/can.c  ****     if (api_status == R_CAN_OK)
 185                             		.loc 1 860 18 is_stmt 0 view .LVU60
 186 0000 66 02                   		mov.L	#0, r2
 187 0002 66 11                   		mov.L	#1, r1
 188 0004 05 00 00 00             		bsr	_R_CAN_TxCheck
 189                             	.LVL11:
 861:../src/can.c  ****     {
 190                             		.loc 1 861 5 is_stmt 1 view .LVU61
 861:../src/can.c  ****     {
 191                             		.loc 1 861 8 is_stmt 0 view .LVU62
 192 0008 61 01                   		cmp	#0, r1
 193 000a 1A                      		bne	.L12
 863:../src/can.c  ****     }
 194                             		.loc 1 863 9 is_stmt 1 view .LVU63
 863:../src/can.c  ****     }
 195                             		.loc 1 863 31 is_stmt 0 view .LVU64
 196 000b FB 52 00 00 00 00       		mov.L	#_CAN0_tx_sentdata_flag, r5
 197 0011 F8 56 01                		mov.L	#1, [r5]
 198                             	.L12:
 874:../src/can.c  **** 
 199                             		.loc 1 874 1 view .LVU65
 200 0014 02                      		rts
 201                             	.LFE11:
 203                             		.section	.text.init_can_app,"ax",@progbits
 205                             	_init_can_app:
 206                             	.LFB6:
 571:../src/can.c  ****     uint32_t    api_status = R_CAN_OK;
 207                             		.loc 1 571 1 is_stmt 1 view -0
 208 0000 6E 7A                   		pushm	r7-r10
 209                             	.LCFI1:
 572:../src/can.c  ****     uint8_t     i;
 210                             		.loc 1 572 5 view .LVU67
 211                             	.LVL12:
 573:../src/can.c  **** 
 212                             		.loc 1 573 5 view .LVU68
 575:../src/can.c  **** 
 213                             		.loc 1 575 5 view .LVU69
 575:../src/can.c  **** 
 214                             		.loc 1 575 18 is_stmt 0 view .LVU70
 215 0002 FB 72 00 00 00 00       		mov.L	#_can_state, r7
 216 0008 F8 76 01                		mov.L	#1, [r7]
 578:../src/can.c  ****     {
 217                             		.loc 1 578 5 is_stmt 1 view .LVU71
 218                             	.LVL13:
 578:../src/can.c  ****     {
 219                             		.loc 1 578 12 is_stmt 0 view .LVU72
 220 000b 66 05                   		mov	#0, r5
 578:../src/can.c  ****     {
 221                             		.loc 1 578 5 view .LVU73
 222 000d 2E 1A                   		bra	.L15
 223                             	.LVL14:
 224                             	.L16:
 580:../src/can.c  ****         error_bus_status_prev[i] = R_CAN_STATUS_ERROR_ACTIVE;
 225                             		.loc 1 580 9 is_stmt 1 discriminator 3 view .LVU74
 580:../src/can.c  ****         error_bus_status_prev[i] = R_CAN_STATUS_ERROR_ACTIVE;
 226                             		.loc 1 580 25 is_stmt 0 discriminator 3 view .LVU75
 227 000f 5B 57                   		movu.B	r5, r7
 580:../src/can.c  ****         error_bus_status_prev[i] = R_CAN_STATUS_ERROR_ACTIVE;
 228                             		.loc 1 580 29 discriminator 3 view .LVU76
 229 0011 FB A2 00 00 00 00       		mov.L	#_error_bus_status, r10
 230 0017 66 14                   		mov.L	#1, r4
 231 0019 FE 27 A4                		mov.L	r4, [r7,r10]
 581:../src/can.c  ****     }
 232                             		.loc 1 581 9 is_stmt 1 discriminator 3 view .LVU77
 581:../src/can.c  ****     }
 233                             		.loc 1 581 34 is_stmt 0 discriminator 3 view .LVU78
 234 001c FB A2 00 00 00 00       		mov.L	#_error_bus_status_prev, r10
 235 0022 FE 27 A4                		mov.L	r4, [r7,r10]
 578:../src/can.c  ****     {
 236                             		.loc 1 578 39 discriminator 3 view .LVU79
 237 0025 4B 45                   		add	r4, r5
 238                             	.LVL15:
 239                             	.L15:
 578:../src/can.c  ****     {
 240                             		.loc 1 578 5 discriminator 1 view .LVU80
 241 0027 5B 57                   		movu.B	r5, r7
 242 0029 61 27                   		cmp	#2, r7
 243 002b 25 E4                   		bleu	.L16
 587:../src/can.c  ****     {
 244                             		.loc 1 587 5 is_stmt 1 view .LVU81
 590:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX2, RX_CANID_DEMO_INIT2, DATA_FRAME);
 245                             		.loc 1 590 9 view .LVU82
 590:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX2, RX_CANID_DEMO_INIT2, DATA_FRAME);
 246                             		.loc 1 590 23 is_stmt 0 view .LVU83
 247 002d FB 72 00 00 00 00       		mov.L	#_g_can_channel, r7
 248 0033 66 04                   		mov.L	#0, r4
 249 0035 FB 3A E8 03             		mov.L	#0x3e8, r3
 250 0039 66 42                   		mov.L	#4, r2
 251 003b EC 71                   		mov.L	[r7], r1
 252 003d 05 00 00 00             		bsr	_R_CAN_RxSet
 253                             	.LVL16:
 590:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX2, RX_CANID_DEMO_INIT2, DATA_FRAME);
 254                             		.loc 1 590 23 view .LVU84
 255 0041 EF 1A                   		mov.L	r1, r10
 256                             	.LVL17:
 591:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX3, RX_CANID_DEMO_INIT3, DATA_FRAME);
 257                             		.loc 1 591 9 is_stmt 1 view .LVU85
 591:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX3, RX_CANID_DEMO_INIT3, DATA_FRAME);
 258                             		.loc 1 591 23 is_stmt 0 view .LVU86
 259 0043 66 04                   		mov.L	#0, r4
 260 0045 FB 3A E9 03             		mov.L	#0x3e9, r3
 261 0049 66 52                   		mov.L	#5, r2
 262 004b EC 71                   		mov.L	[r7], r1
 263                             	.LVL18:
 591:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX3, RX_CANID_DEMO_INIT3, DATA_FRAME);
 264                             		.loc 1 591 23 view .LVU87
 265 004d 05 00 00 00             		bsr	_R_CAN_RxSet
 266                             	.LVL19:
 591:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX3, RX_CANID_DEMO_INIT3, DATA_FRAME);
 267                             		.loc 1 591 20 view .LVU88
 268 0051 57 1A                   		or	r1, r10
 269                             	.LVL20:
 592:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX4, RX_CANID_DEMO_INIT4, DATA_FRAME);
 270                             		.loc 1 592 9 is_stmt 1 view .LVU89
 592:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX4, RX_CANID_DEMO_INIT4, DATA_FRAME);
 271                             		.loc 1 592 23 is_stmt 0 view .LVU90
 272 0053 66 04                   		mov.L	#0, r4
 273 0055 FB 3A EA 03             		mov.L	#0x3ea, r3
 274 0059 66 62                   		mov.L	#6, r2
 275 005b EC 71                   		mov.L	[r7], r1
 276 005d 05 00 00 00             		bsr	_R_CAN_RxSet
 277                             	.LVL21:
 592:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX4, RX_CANID_DEMO_INIT4, DATA_FRAME);
 278                             		.loc 1 592 20 view .LVU91
 279 0061 57 1A                   		or	r1, r10
 280                             	.LVL22:
 593:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX5, RX_CANID_DEMO_INIT5, DATA_FRAME);
 281                             		.loc 1 593 9 is_stmt 1 view .LVU92
 593:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX5, RX_CANID_DEMO_INIT5, DATA_FRAME);
 282                             		.loc 1 593 23 is_stmt 0 view .LVU93
 283 0063 66 04                   		mov.L	#0, r4
 284 0065 FB 3A EB 03             		mov.L	#0x3eb, r3
 285 0069 66 72                   		mov.L	#7, r2
 286 006b EC 71                   		mov.L	[r7], r1
 287 006d 05 00 00 00             		bsr	_R_CAN_RxSet
 288                             	.LVL23:
 593:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX5, RX_CANID_DEMO_INIT5, DATA_FRAME);
 289                             		.loc 1 593 20 view .LVU94
 290 0071 57 1A                   		or	r1, r10
 291                             	.LVL24:
 594:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX6, RX_CANID_DEMO_INIT6, DATA_FRAME);
 292                             		.loc 1 594 9 is_stmt 1 view .LVU95
 594:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX6, RX_CANID_DEMO_INIT6, DATA_FRAME);
 293                             		.loc 1 594 23 is_stmt 0 view .LVU96
 294 0073 66 04                   		mov.L	#0, r4
 295 0075 FB 3A EC 03             		mov.L	#0x3ec, r3
 296 0079 66 82                   		mov.L	#8, r2
 297 007b EC 71                   		mov.L	[r7], r1
 298 007d 05 00 00 00             		bsr	_R_CAN_RxSet
 299                             	.LVL25:
 594:../src/can.c  ****         api_status |= R_CAN_RxSet(g_can_channel, CANBOX_RX6, RX_CANID_DEMO_INIT6, DATA_FRAME);
 300                             		.loc 1 594 20 view .LVU97
 301 0081 57 1A                   		or	r1, r10
 302                             	.LVL26:
 595:../src/can.c  **** 
 303                             		.loc 1 595 9 is_stmt 1 view .LVU98
 595:../src/can.c  **** 
 304                             		.loc 1 595 23 is_stmt 0 view .LVU99
 305 0083 66 04                   		mov.L	#0, r4
 306 0085 FB 3A ED 03             		mov.L	#0x3ed, r3
 307 0089 66 92                   		mov.L	#9, r2
 308 008b EC 71                   		mov.L	[r7], r1
 309 008d 05 00 00 00             		bsr	_R_CAN_RxSet
 310                             	.LVL27:
 595:../src/can.c  **** 
 311                             		.loc 1 595 20 view .LVU100
 312 0091 57 1A                   		or	r1, r10
 313                             	.LVL28:
 601:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX2, 0x7FF);
 314                             		.loc 1 601 9 is_stmt 1 view .LVU101
 315 0093 FB 3A FF 07             		mov.L	#0x7ff, r3
 316 0097 66 42                   		mov.L	#4, r2
 317 0099 EC 71                   		mov.L	[r7], r1
 318 009b 05 00 00 00             		bsr	_R_CAN_RxSetMask
 319                             	.LVL29:
 602:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX3, 0x7FF);
 320                             		.loc 1 602 9 view .LVU102
 321 009f FB 3A FF 07             		mov.L	#0x7ff, r3
 322 00a3 66 52                   		mov.L	#5, r2
 323 00a5 EC 71                   		mov.L	[r7], r1
 324 00a7 05 00 00 00             		bsr	_R_CAN_RxSetMask
 325                             	.LVL30:
 603:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX4, 0x7FF);
 326                             		.loc 1 603 9 view .LVU103
 327 00ab FB 3A FF 07             		mov.L	#0x7ff, r3
 328 00af 66 62                   		mov.L	#6, r2
 329 00b1 EC 71                   		mov.L	[r7], r1
 330 00b3 05 00 00 00             		bsr	_R_CAN_RxSetMask
 331                             	.LVL31:
 604:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX5, 0x7FF);
 332                             		.loc 1 604 9 view .LVU104
 333 00b7 FB 3A FF 07             		mov.L	#0x7ff, r3
 334 00bb 66 72                   		mov.L	#7, r2
 335 00bd EC 71                   		mov.L	[r7], r1
 336 00bf 05 00 00 00             		bsr	_R_CAN_RxSetMask
 337                             	.LVL32:
 605:../src/can.c  ****         R_CAN_RxSetMask(g_can_channel, CANBOX_RX6, 0x7FF);
 338                             		.loc 1 605 9 view .LVU105
 339 00c3 FB 3A FF 07             		mov.L	#0x7ff, r3
 340 00c7 66 82                   		mov.L	#8, r2
 341 00c9 EC 71                   		mov.L	[r7], r1
 342 00cb 05 00 00 00             		bsr	_R_CAN_RxSetMask
 343                             	.LVL33:
 606:../src/can.c  ****     }
 344                             		.loc 1 606 9 view .LVU106
 345 00cf FB 3A FF 07             		mov.L	#0x7ff, r3
 346 00d3 66 92                   		mov.L	#9, r2
 347 00d5 EC 71                   		mov.L	[r7], r1
 348 00d7 05 00 00 00             		bsr	_R_CAN_RxSetMask
 349                             	.LVL34:
 622:../src/can.c  ****     tx_dataframe.dlc        = 8;
 350                             		.loc 1 622 5 view .LVU107
 622:../src/can.c  ****     tx_dataframe.dlc        = 8;
 351                             		.loc 1 622 29 is_stmt 0 view .LVU108
 352 00db FB 72 00 00 00 00       		mov.L	#_tx_dataframe, r7
 353 00e1 F8 7A A0 00             		mov.L	#0xa0, [r7]
 623:../src/can.c  ****     for (i = 0; i < 8; i++)
 354                             		.loc 1 623 5 is_stmt 1 view .LVU109
 623:../src/can.c  ****     for (i = 0; i < 8; i++)
 355                             		.loc 1 623 29 is_stmt 0 view .LVU110
 356 00e5 3C 74 08                		mov.B	#8, 4[r7]
 624:../src/can.c  ****     {
 357                             		.loc 1 624 5 is_stmt 1 view .LVU111
 358                             	.LVL35:
 624:../src/can.c  ****     {
 359                             		.loc 1 624 12 is_stmt 0 view .LVU112
 360 00e8 66 05                   		mov	#0, r5
 624:../src/can.c  ****     {
 361                             		.loc 1 624 5 view .LVU113
 362 00ea 2E 0E                   		bra	.L17
 363                             	.LVL36:
 364                             	.L18:
 626:../src/can.c  ****     }
 365                             		.loc 1 626 9 is_stmt 1 discriminator 3 view .LVU114
 626:../src/can.c  ****     }
 366                             		.loc 1 626 26 is_stmt 0 discriminator 3 view .LVU115
 367 00ec 5B 54                   		movu.B	r5, r4
 626:../src/can.c  ****     }
 368                             		.loc 1 626 33 discriminator 3 view .LVU116
 369 00ee 70 44 00 00 00 00       		add	#_tx_dataframe, r4
 370 00f4 81 4D                   		mov.B	r5, 5[r4]
 624:../src/can.c  ****     {
 371                             		.loc 1 624 25 discriminator 3 view .LVU117
 372 00f6 62 15                   		add	#1, r5
 373                             	.LVL37:
 374                             	.L17:
 624:../src/can.c  ****     {
 375                             		.loc 1 624 5 discriminator 1 view .LVU118
 376 00f8 5B 54                   		movu.B	r5, r4
 377 00fa 61 74                   		cmp	#7, r4
 378 00fc 25 F0                   		bleu	.L18
 655:../src/can.c  ****     rx_dataframe2.id = RX_CANID_DEMO_INIT2;
 379                             		.loc 1 655 5 is_stmt 1 view .LVU119
 655:../src/can.c  ****     rx_dataframe2.id = RX_CANID_DEMO_INIT2;
 380                             		.loc 1 655 22 is_stmt 0 view .LVU120
 381 00fe FB 72 00 00 00 00       		mov.L	#_rx_dataframe1, r7
 382 0104 F8 7A E8 03             		mov.L	#0x3e8, [r7]
 656:../src/can.c  ****     rx_dataframe3.id = RX_CANID_DEMO_INIT3;
 383                             		.loc 1 656 5 is_stmt 1 view .LVU121
 656:../src/can.c  ****     rx_dataframe3.id = RX_CANID_DEMO_INIT3;
 384                             		.loc 1 656 22 is_stmt 0 view .LVU122
 385 0108 FB 72 00 00 00 00       		mov.L	#_rx_dataframe2, r7
 386 010e F8 7A E9 03             		mov.L	#0x3e9, [r7]
 657:../src/can.c  ****     rx_dataframe4.id = RX_CANID_DEMO_INIT4;
 387                             		.loc 1 657 5 is_stmt 1 view .LVU123
 657:../src/can.c  ****     rx_dataframe4.id = RX_CANID_DEMO_INIT4;
 388                             		.loc 1 657 22 is_stmt 0 view .LVU124
 389 0112 FB 72 00 00 00 00       		mov.L	#_rx_dataframe3, r7
 390 0118 F8 7A EA 03             		mov.L	#0x3ea, [r7]
 658:../src/can.c  ****     rx_dataframe5.id = RX_CANID_DEMO_INIT5;
 391                             		.loc 1 658 5 is_stmt 1 view .LVU125
 658:../src/can.c  ****     rx_dataframe5.id = RX_CANID_DEMO_INIT5;
 392                             		.loc 1 658 22 is_stmt 0 view .LVU126
 393 011c FB 72 00 00 00 00       		mov.L	#_rx_dataframe4, r7
 394 0122 F8 7A EB 03             		mov.L	#0x3eb, [r7]
 659:../src/can.c  ****     rx_dataframe6.id = RX_CANID_DEMO_INIT6;
 395                             		.loc 1 659 5 is_stmt 1 view .LVU127
 659:../src/can.c  ****     rx_dataframe6.id = RX_CANID_DEMO_INIT6;
 396                             		.loc 1 659 22 is_stmt 0 view .LVU128
 397 0126 FB 72 00 00 00 00       		mov.L	#_rx_dataframe5, r7
 398 012c F8 7A EC 03             		mov.L	#0x3ec, [r7]
 660:../src/can.c  **** 
 399                             		.loc 1 660 5 is_stmt 1 view .LVU129
 660:../src/can.c  **** 
 400                             		.loc 1 660 22 is_stmt 0 view .LVU130
 401 0130 FB 72 00 00 00 00       		mov.L	#_rx_dataframe6, r7
 402 0136 F8 7A ED 03             		mov.L	#0x3ed, [r7]
 662:../src/can.c  **** 
 403                             		.loc 1 662 5 is_stmt 1 view .LVU131
 664:../src/can.c  **** } /* end init_can_app */
 404                             		.loc 1 664 5 view .LVU132
 665:../src/can.c  **** 
 405                             		.loc 1 665 1 is_stmt 0 view .LVU133
 406 013a EF A1                   		mov.L	r10, r1
 407 013c 3F 7A 04                		rtsd	#16, r7-r10
 665:../src/can.c  **** 
 408                             		.loc 1 665 1 view .LVU134
 409                             	.LFE6:
 411                             		.section	.text.handle_can_bus_state,"ax",@progbits
 413                             	_handle_can_bus_state:
 414                             	.LVL38:
 415                             	.LFB8:
 701:../src/can.c  ****     /* Has the status register reached error passive or more? */
 416                             		.loc 1 701 1 is_stmt 1 view -0
 701:../src/can.c  ****     /* Has the status register reached error passive or more? */
 417                             		.loc 1 701 1 is_stmt 0 view .LVU136
 418 0000 7E A7                   		push.l	r7
 419                             	.LCFI2:
 420 0002 71 00 F0                		add	#-16, r0
 421                             	.LCFI3:
 703:../src/can.c  ****     {
 422                             		.loc 1 703 5 is_stmt 1 view .LVU137
 703:../src/can.c  ****     {
 423                             		.loc 1 703 8 is_stmt 0 view .LVU138
 424 0005 5B 17                   		movu.B	r1, r7
 425 0007 61 27                   		cmp	#2, r7
 426 0009 25 05                   		bleu	.L27
 427                             	.LVL39:
 428                             	.L20:
 763:../src/can.c  **** 
 429                             		.loc 1 763 1 view .LVU139
 430 000b 3F 77 05                		rtsd	#20, r7-r7
 431                             	.LVL40:
 432                             	.L27:
 705:../src/can.c  ****     }
 433                             		.loc 1 705 9 is_stmt 1 view .LVU140
 705:../src/can.c  ****     }
 434                             		.loc 1 705 35 is_stmt 0 view .LVU141
 435 000e EF 71                   		mov.L	r7, r1
 436                             	.LVL41:
 705:../src/can.c  ****     }
 437                             		.loc 1 705 35 view .LVU142
 438 0010 05 00 00 00             		bsr	_R_CAN_CheckErr
 439                             	.LVL42:
 705:../src/can.c  ****     }
 440                             		.loc 1 705 33 view .LVU143
 441 0014 FB 52 00 00 00 00       		mov.L	#_error_bus_status, r5
 442 001a FE 27 51                		mov.L	r1, [r7,r5]
 714:../src/can.c  ****     {
 443                             		.loc 1 714 5 is_stmt 1 view .LVU144
 714:../src/can.c  ****     {
 444                             		.loc 1 714 57 is_stmt 0 view .LVU145
 445 001d FB 52 00 00 00 00       		mov.L	#_error_bus_status_prev, r5
 446 0023 FE 67 55                		mov.L	[r7,r5], r5
 714:../src/can.c  ****     {
 447                             		.loc 1 714 8 view .LVU146
 448 0026 47 51                   		cmp	r5, r1
 449 0028 20 E3                   		beq	.L20
 716:../src/can.c  ****         {
 450                             		.loc 1 716 9 is_stmt 1 view .LVU147
 451 002a 61 11                   		cmp	#1, r1
 452 002c 20 28                   		beq	.L22
 453 002e 61 21                   		cmp	#2, r1
 454 0030 20 10                   		beq	.L23
 755:../src/can.c  ****                 #if BSP_CFG_IO_LIB_ENABLE
 455                             		.loc 1 755 17 view .LVU148
 755:../src/can.c  ****                 #if BSP_CFG_IO_LIB_ENABLE
 456                             		.loc 1 755 40 is_stmt 0 view .LVU149
 457 0032 FB 42 00 00 00 00       		mov.L	#_nr_times_reached_busoff, r4
 458 0038 FE 67 45                		mov.L	[r7,r4], r5
 755:../src/can.c  ****                 #if BSP_CFG_IO_LIB_ENABLE
 459                             		.loc 1 755 47 view .LVU150
 460 003b 62 15                   		add	#1, r5
 461 003d FE 27 45                		mov.L	r5, [r7,r4]
 759:../src/can.c  ****         }
 462                             		.loc 1 759 17 is_stmt 1 view .LVU151
 463                             		.balign 8,3,5
 464                             	.L23:
 761:../src/can.c  ****     }
 465                             		.loc 1 761 9 view .LVU152
 761:../src/can.c  ****     }
 466                             		.loc 1 761 38 is_stmt 0 view .LVU153
 467 0040 FB 42 00 00 00 00       		mov.L	#_error_bus_status, r4
 468 0046 FB 52 00 00 00 00       		mov.L	#_error_bus_status_prev, r5
 469 004c FE 67 44                		mov.L	[r7,r4], r4
 470 004f FE 27 54                		mov.L	r4, [r7,r5]
 471 0052 2E B9                   		bra	.L20
 472                             	.L22:
 721:../src/can.c  ****                 {
 473                             		.loc 1 721 17 is_stmt 1 view .LVU154
 726:../src/can.c  ****                 /* Restart if returned from Bus Off. */
 474                             		.loc 1 726 17 view .LVU155
 728:../src/can.c  ****                 {
 475                             		.loc 1 728 17 view .LVU156
 728:../src/can.c  ****                 {
 476                             		.loc 1 728 20 is_stmt 0 view .LVU157
 477 0054 61 45                   		cmp	#4, r5
 478 0056 21 EA                   		bne	.L23
 738:../src/can.c  ****                     #endif
 479                             		.loc 1 738 25 is_stmt 1 view .LVU158
 738:../src/can.c  ****                     #endif
 480                             		.loc 1 738 29 is_stmt 0 view .LVU159
 481 0058 F9 02 03 00 00 00 00    		mov.L	#_my_can_err0_callback, 12[r0]
 482 005f 3E 02 00                		mov.L	#0, 8[r0]
 483 0062 F9 02 01 00 00 00 00    		mov.L	#_my_can_rx0_callback, 4[r0]
 484 0069 F8 06 00                		mov.L	#0, [r0]
 485 006c FB 42 00 00 00 00       		mov.L	#_my_can_tx0_callback, r4
 486 0072 FB 52 00 00 00 00       		mov.L	#_CAN0_bitrate_cfg, r5
 487 0078 EC 53                   		mov.L	[r5], r3
 488 007a FB 52 00 00 00 00       		mov.L	#_g_mb_mode, r5
 489 0080 EC 52                   		mov.L	[r5], r2
 490 0082 FB 52 00 00 00 00       		mov.L	#_g_can_channel, r5
 491 0088 EC 51                   		mov.L	[r5], r1
 492 008a 05 00 00 00             		bsr	_R_CAN_Create
 493                             	.LVL43:
 738:../src/can.c  ****                     #endif
 494                             		.loc 1 738 28 view .LVU160
 495 008e 61 01                   		cmp	#0, r1
 496 0090 20 B0                   		beq	.L23
 742:../src/can.c  ****                 }
 497                             		.loc 1 742 21 is_stmt 1 view .LVU161
 498 0092 05 00 00 00             		bsr	_init_can_app
 499                             	.LVL44:
 500 0096 2E AA                   		bra	.L23
 501                             	.LFE8:
 503                             		.section	.text.check_can_errors,"ax",@progbits
 505                             	_check_can_errors:
 506                             	.LFB7:
 675:../src/can.c  ****     /* Error passive or more? */
 507                             		.loc 1 675 1 view -0
 677:../src/can.c  **** 
 508                             		.loc 1 677 5 view .LVU163
 509 0000 FB 52 00 00 00 00       		mov.L	#_g_can_channel, r5
 510 0006 CC 51                   		mov.B	[r5], r1
 511 0008 05 00 00 00             		bsr	_handle_can_bus_state
 512                             	.LVL45:
 679:../src/can.c  ****     {
 513                             		.loc 1 679 5 view .LVU164
 679:../src/can.c  ****     {
 514                             		.loc 1 679 9 is_stmt 0 view .LVU165
 515 000c FB 52 00 00 00 00       		mov.L	#_app_err_nr, r5
 516 0012 EC 55                   		mov.L	[r5], r5
 679:../src/can.c  ****     {
 517                             		.loc 1 679 8 view .LVU166
 518 0014 61 05                   		cmp	#0, r5
 519 0016 20 18                   		beq	.L28
 685:../src/can.c  **** 
 520                             		.loc 1 685 9 is_stmt 1 view .LVU167
 685:../src/can.c  **** 
 521                             		.loc 1 685 20 is_stmt 0 view .LVU168
 522 0018 FB 52 00 00 00 00       		mov.L	#_app_err_nr, r5
 523 001e F8 56 00                		mov.L	#0, [r5]
 690:../src/can.c  ****     }
 524                             		.loc 1 690 9 is_stmt 1 view .LVU169
 690:../src/can.c  ****     }
 525                             		.loc 1 690 14 is_stmt 0 view .LVU170
 526 0021 FB 5E 09 C0 08          		mov.L	#0x8c009, r5
 527 0026 CD 54 20                		mov.B	32[r5], r4
 528 0029 78 64                   		bset	#6, r4
 529 002b C7 54 20                		mov.B	r4, 32[r5]
 530                             	.L28:
 692:../src/can.c  **** 
 531                             		.loc 1 692 1 view .LVU171
 532 002e 02                      		rts
 533                             	.LFE7:
 535                             		.section	.text.can_int_demo,"ax",@progbits
 537                             	_can_int_demo:
 538                             	.LFB5:
 485:../src/can.c  ****     uint32_t    api_status = R_CAN_OK;
 539                             		.loc 1 485 1 is_stmt 1 view -0
 540 0000 6E 7A                   		pushm	r7-r10
 541                             	.LCFI4:
 486:../src/can.c  **** 
 542                             		.loc 1 486 5 view .LVU173
 543                             	.LVL46:
 489:../src/can.c  ****     {
 544                             		.loc 1 489 5 view .LVU174
 489:../src/can.c  ****     {
 545                             		.loc 1 489 9 is_stmt 0 view .LVU175
 546 0002 FB 72 00 00 00 00       		mov.L	#_CAN0_tx_sentdata_flag, r7
 547 0008 EC 77                   		mov.L	[r7], r7
 489:../src/can.c  ****     {
 548                             		.loc 1 489 8 view .LVU176
 549 000a 61 07                   		cmp	#0, r7
 550 000c 20 24                   		beq	.L31
 491:../src/can.c  ****         LED1 = LED_ON;
 551                             		.loc 1 491 9 is_stmt 1 view .LVU177
 491:../src/can.c  ****         LED1 = LED_ON;
 552                             		.loc 1 491 31 is_stmt 0 view .LVU178
 553 000e FB 72 00 00 00 00       		mov.L	#_CAN0_tx_sentdata_flag, r7
 554 0014 F8 76 00                		mov.L	#0, [r7]
 492:../src/can.c  ****         nr_frames_tx++;
 555                             		.loc 1 492 9 is_stmt 1 view .LVU179
 492:../src/can.c  ****         nr_frames_tx++;
 556                             		.loc 1 492 14 is_stmt 0 view .LVU180
 557 0017 FB 7E 09 C0 08          		mov.L	#0x8c009, r7
 558 001c CD 7A 20                		mov.B	32[r7], r10
 559 001f 78 6A                   		bset	#6, r10
 560 0021 C7 7A 20                		mov.B	r10, 32[r7]
 493:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 561                             		.loc 1 493 9 is_stmt 1 view .LVU181
 493:../src/can.c  ****         #if BSP_CFG_IO_LIB_ENABLE
 562                             		.loc 1 493 21 is_stmt 0 view .LVU182
 563 0024 FB A2 00 00 00 00       		mov.L	#_nr_frames_tx, r10
 564 002a EC A7                   		mov.L	[r10], r7
 565 002c 62 17                   		add	#1, r7
 566 002e E3 A7                   		mov.L	r7, [r10]
 567                             	.L31:
 501:../src/can.c  ****     {
 568                             		.loc 1 501 5 is_stmt 1 view .LVU183
 501:../src/can.c  ****     {
 569                             		.loc 1 501 9 is_stmt 0 view .LVU184
 570 0030 FB 72 00 00 00 00       		mov.L	#_CAN0_rx_newdata_flag, r7
 571 0036 EC 77                   		mov.L	[r7], r7
 501:../src/can.c  ****     {
 572                             		.loc 1 501 8 view .LVU185
 573 0038 61 07                   		cmp	#0, r7
 574 003a 1C                      		bne	.L34
 575                             	.LVL47:
 576                             	.L30:
 558:../src/can.c  **** #endif
 577                             		.loc 1 558 1 view .LVU186
 578 003b 3F 7A 04                		rtsd	#16, r7-r10
 579                             	.LVL48:
 580                             	.L34:
 503:../src/can.c  ****         LED0 = LED_ON;
 581                             		.loc 1 503 9 is_stmt 1 view .LVU187
 503:../src/can.c  ****         LED0 = LED_ON;
 582                             		.loc 1 503 30 is_stmt 0 view .LVU188
 583 003e FB 72 00 00 00 00       		mov.L	#_CAN0_rx_newdata_flag, r7
 584 0044 F8 76 00                		mov.L	#0, [r7]
 504:../src/can.c  ****         nr_frames_rx++;
 585                             		.loc 1 504 9 is_stmt 1 view .LVU189
 504:../src/can.c  ****         nr_frames_rx++;
 586                             		.loc 1 504 14 is_stmt 0 view .LVU190
 587 0047 FB 7E 09 C0 08          		mov.L	#0x8c009, r7
 588 004c CD 7A 20                		mov.B	32[r7], r10
 589 004f 78 5A                   		bset	#5, r10
 590 0051 C7 7A 20                		mov.B	r10, 32[r7]
 505:../src/can.c  **** 
 591                             		.loc 1 505 9 is_stmt 1 view .LVU191
 505:../src/can.c  **** 
 592                             		.loc 1 505 21 is_stmt 0 view .LVU192
 593 0054 FB A2 00 00 00 00       		mov.L	#_nr_frames_rx, r10
 594 005a EC A7                   		mov.L	[r10], r7
 595 005c 62 17                   		add	#1, r7
 596 005e E3 A7                   		mov.L	r7, [r10]
 509:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX2, &rx_dataframe2);
 597                             		.loc 1 509 9 is_stmt 1 view .LVU193
 509:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX2, &rx_dataframe2);
 598                             		.loc 1 509 22 is_stmt 0 view .LVU194
 599 0060 FB A2 00 00 00 00       		mov.L	#_g_mb_mode, r10
 600 0066 FB 72 00 00 00 00       		mov.L	#_g_can_channel, r7
 601 006c FB 42 00 00 00 00       		mov.L	#_rx_dataframe1, r4
 602 0072 66 43                   		mov.L	#4, r3
 603 0074 EC A2                   		mov.L	[r10], r2
 604 0076 EC 71                   		mov.L	[r7], r1
 605 0078 05 00 00 00             		bsr	_R_CAN_RxRead
 606                             	.LVL49:
 510:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX3, &rx_dataframe3);
 607                             		.loc 1 510 9 is_stmt 1 view .LVU195
 510:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX3, &rx_dataframe3);
 608                             		.loc 1 510 22 is_stmt 0 view .LVU196
 609 007c FB 42 00 00 00 00       		mov.L	#_rx_dataframe2, r4
 610 0082 66 53                   		mov.L	#5, r3
 611 0084 EC A2                   		mov.L	[r10], r2
 612 0086 EC 71                   		mov.L	[r7], r1
 613 0088 05 00 00 00             		bsr	_R_CAN_RxRead
 614                             	.LVL50:
 511:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX4, &rx_dataframe4);
 615                             		.loc 1 511 9 is_stmt 1 view .LVU197
 511:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX4, &rx_dataframe4);
 616                             		.loc 1 511 22 is_stmt 0 view .LVU198
 617 008c FB 42 00 00 00 00       		mov.L	#_rx_dataframe3, r4
 618 0092 66 63                   		mov.L	#6, r3
 619 0094 EC A2                   		mov.L	[r10], r2
 620 0096 EC 71                   		mov.L	[r7], r1
 621 0098 05 00 00 00             		bsr	_R_CAN_RxRead
 622                             	.LVL51:
 512:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX5, &rx_dataframe5);
 623                             		.loc 1 512 9 is_stmt 1 view .LVU199
 512:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX5, &rx_dataframe5);
 624                             		.loc 1 512 22 is_stmt 0 view .LVU200
 625 009c FB 42 00 00 00 00       		mov.L	#_rx_dataframe4, r4
 626 00a2 66 73                   		mov.L	#7, r3
 627 00a4 EC A2                   		mov.L	[r10], r2
 628 00a6 EC 71                   		mov.L	[r7], r1
 629 00a8 05 00 00 00             		bsr	_R_CAN_RxRead
 630                             	.LVL52:
 513:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX6, &rx_dataframe6);
 631                             		.loc 1 513 9 is_stmt 1 view .LVU201
 513:../src/can.c  ****         api_status = R_CAN_RxRead(g_can_channel, g_mb_mode, CANBOX_RX6, &rx_dataframe6);
 632                             		.loc 1 513 22 is_stmt 0 view .LVU202
 633 00ac FB 42 00 00 00 00       		mov.L	#_rx_dataframe5, r4
 634 00b2 66 83                   		mov.L	#8, r3
 635 00b4 EC A2                   		mov.L	[r10], r2
 636 00b6 EC 71                   		mov.L	[r7], r1
 637 00b8 05 00 00 00             		bsr	_R_CAN_RxRead
 638                             	.LVL53:
 514:../src/can.c  **** 
 639                             		.loc 1 514 9 is_stmt 1 view .LVU203
 514:../src/can.c  **** 
 640                             		.loc 1 514 22 is_stmt 0 view .LVU204
 641 00bc FB 42 00 00 00 00       		mov.L	#_rx_dataframe6, r4
 642 00c2 66 93                   		mov.L	#9, r3
 643 00c4 EC A2                   		mov.L	[r10], r2
 644 00c6 EC 71                   		mov.L	[r7], r1
 645 00c8 05 00 00 00             		bsr	_R_CAN_RxRead
 646                             	.LVL54:
 517:../src/can.c  **** 
 647                             		.loc 1 517 9 is_stmt 1 view .LVU205
 648                             	 ; 517 "../src/can.c" 1
 649 00cc 03                      		nop
 650                             	 ; 0 "" 2
 523:../src/can.c  ****         {
 651                             		.loc 1 523 9 view .LVU206
 523:../src/can.c  ****         {
 652                             		.loc 1 523 12 is_stmt 0 view .LVU207
 653 00cd 61 41                   		cmp	#4, r1
 654 00cf 3B 6C FF                		bne	.L30
 528:../src/can.c  ****         }
 655                             		.loc 1 528 13 is_stmt 1 view .LVU208
 656                             	 ; 528 "../src/can.c" 1
 657 00d2 03                      		nop
 658                             	 ; 0 "" 2
 558:../src/can.c  **** #endif
 659                             		.loc 1 558 1 is_stmt 0 view .LVU209
 660 00d3 38 68 FF                		bra	.L30
 661                             	.LFE5:
 663                             		.section	.text.Init_CAN,"ax",@progbits
 664                             		.global	_Init_CAN
 666                             	_Init_CAN:
 667                             	.LFB3:
 216:../src/can.c  ****   uint32_t  api_status = R_CAN_OK;
 668                             		.loc 1 216 1 is_stmt 1 view -0
 669 0000 7E A7                   		push.l	r7
 670                             	.LCFI5:
 671 0002 71 00 F0                		add	#-16, r0
 672                             	.LCFI6:
 217:../src/can.c  **** //  uint32_t  i, bus_status;
 673                             		.loc 1 217 3 view .LVU211
 674                             	.LVL55:
 226:../src/can.c  **** 
 675                             		.loc 1 226 5 view .LVU212
 676 0005 05 00 00 00             		bsr	_demo_output_ports_configure
 677                             	.LVL56:
 229:../src/can.c  **** 
 678                             		.loc 1 229 5 view .LVU213
 679 0009 75 41 1E                		mov.L	#30, r1
 680 000c 05 00 00 00             		bsr	_test_leds
 681                             	.LVL57:
 232:../src/can.c  ****     CAN0_bitrate_cfg.SJW = CAN0_SJW;
 682                             		.loc 1 232 5 view .LVU214
 232:../src/can.c  ****     CAN0_bitrate_cfg.SJW = CAN0_SJW;
 683                             		.loc 1 232 26 is_stmt 0 view .LVU215
 684 0010 FB 52 00 00 00 00       		mov.L	#_CAN0_bitrate_cfg, r5
 685 0016 F8 54 05                		mov.B	#5, [r5]
 233:../src/can.c  ****     CAN0_bitrate_cfg.TSEG1 = CAN0_TSEG1;
 686                             		.loc 1 233 5 is_stmt 1 view .LVU216
 233:../src/can.c  ****     CAN0_bitrate_cfg.TSEG1 = CAN0_TSEG1;
 687                             		.loc 1 233 26 is_stmt 0 view .LVU217
 688 0019 3C 53 02                		mov.B	#2, 3[r5]
 234:../src/can.c  ****     CAN0_bitrate_cfg.TSEG2 = CAN0_TSEG2;
 689                             		.loc 1 234 5 is_stmt 1 view .LVU218
 234:../src/can.c  ****     CAN0_bitrate_cfg.TSEG2 = CAN0_TSEG2;
 690                             		.loc 1 234 28 is_stmt 0 view .LVU219
 691 001c 3C 51 07                		mov.B	#7, 1[r5]
 235:../src/can.c  **** 
 692                             		.loc 1 235 5 is_stmt 1 view .LVU220
 235:../src/can.c  **** 
 693                             		.loc 1 235 28 is_stmt 0 view .LVU221
 694 001f 3C 52 04                		mov.B	#4, 2[r5]
 241:../src/can.c  ****     #endif
 695                             		.loc 1 241 9 is_stmt 1 view .LVU222
 241:../src/can.c  ****     #endif
 696                             		.loc 1 241 22 is_stmt 0 view .LVU223
 697 0022 F9 02 03 00 00 00 00    		mov.L	#_my_can_err0_callback, 12[r0]
 698 0029 3E 02 00                		mov.L	#0, 8[r0]
 699 002c F9 02 01 00 00 00 00    		mov.L	#_my_can_rx0_callback, 4[r0]
 700 0033 F8 06 00                		mov.L	#0, [r0]
 701 0036 FB 42 00 00 00 00       		mov.L	#_my_can_tx0_callback, r4
 702 003c EC 53                   		mov.L	[r5], r3
 703 003e FB 72 00 00 00 00       		mov.L	#_g_mb_mode, r7
 704 0044 EC 72                   		mov.L	[r7], r2
 705 0046 FB 72 00 00 00 00       		mov.L	#_g_can_channel, r7
 706 004c EC 71                   		mov.L	[r7], r1
 707 004e 05 00 00 00             		bsr	_R_CAN_Create
 708                             	.LVL58:
 244:../src/can.c  ****     {
 709                             		.loc 1 244 5 is_stmt 1 view .LVU224
 244:../src/can.c  ****     {
 710                             		.loc 1 244 8 is_stmt 0 view .LVU225
 711 0052 61 01                   		cmp	#0, r1
 712 0054 13                      		beq	.L36
 713                             	.L37:
 250:../src/can.c  ****         {
 714                             		.loc 1 250 9 is_stmt 1 discriminator 1 view .LVU226
 253:../src/can.c  ****     }
 715                             		.loc 1 253 9 discriminator 1 view .LVU227
 716 0055 2E 00                   		bra	.L37
 717                             	.L36:
 718 0057 EF 17                   		mov.L	r1, r7
 260:../src/can.c  **** //    R_CAN_PinSet_CAN1();
 719                             		.loc 1 260 5 view .LVU228
 720 0059 05 00 00 00             		bsr	_R_CAN_PinSet_CAN0
 721                             	.LVL59:
 269:../src/can.c  **** 
 722                             		.loc 1 269 5 view .LVU229
 269:../src/can.c  **** 
 723                             		.loc 1 269 19 is_stmt 0 view .LVU230
 724 005d 05 00 00 00             		bsr	_init_can_app
 725                             	.LVL60:
 269:../src/can.c  **** 
 726                             		.loc 1 269 16 view .LVU231
 727 0061 57 17                   		or	r1, r7
 728                             	.LVL61:
 272:../src/can.c  ****     {
 729                             		.loc 1 272 5 is_stmt 1 view .LVU232
 272:../src/can.c  ****     {
 730                             		.loc 1 272 8 is_stmt 0 view .LVU233
 731 0063 61 07                   		cmp	#0, r7
 732 0065 12                      		beq	.L38
 274:../src/can.c  ****         app_err_nr = APP_ERR_CAN_INIT;
 733                             		.loc 1 274 9 is_stmt 1 view .LVU234
 734                             	.LVL62:
 275:../src/can.c  ****     }
 735                             		.loc 1 275 9 view .LVU235
 275:../src/can.c  ****     }
 736                             		.loc 1 275 20 is_stmt 0 view .LVU236
 737 0066 FB 72 00 00 00 00       		mov.L	#_app_err_nr, r7
 738 006c F8 76 02                		mov.L	#2, [r7]
 739                             	.LVL63:
 740                             	.L38:
 283:../src/can.c  **** //        api_status |= R_CAN_TxSet(g_can_channel, g_mb_mode, CANBOX_TX, &tx_dataframe, DATA_FRAME)
 741                             		.loc 1 283 9 is_stmt 1 view .LVU237
 742 006f 66 62                   		mov.L	#6, r2
 743 0071 FB 72 00 00 00 00       		mov.L	#_g_can_channel, r7
 744 0077 EC 71                   		mov.L	[r7], r1
 745 0079 05 00 00 00             		bsr	_R_CAN_Control
 746                             	.LVL64:
 358:../src/can.c  **** 
 747                             		.loc 1 358 1 is_stmt 0 view .LVU238
 748 007d 3F 77 05                		rtsd	#20, r7-r7
 749                             	.LFE3:
 751                             		.section	.text.main_CAN,"ax",@progbits
 752                             		.global	_main_CAN
 754                             	_main_CAN:
 755                             	.LFB4:
 361:../src/can.c  **** 	uint32_t  led_show_count;
 756                             		.loc 1 361 1 is_stmt 1 view -0
 362:../src/can.c  **** //	uint32_t  api_status = R_CAN_OK;
 757                             		.loc 1 362 2 view .LVU240
 396:../src/can.c  **** 
 758                             		.loc 1 396 9 view .LVU241
 759 0000 05 00 00 00             		bsr	_check_can_errors
 760                             	.LVL65:
 398:../src/can.c  ****         {
 761                             		.loc 1 398 9 view .LVU242
 398:../src/can.c  ****         {
 762                             		.loc 1 398 22 is_stmt 0 view .LVU243
 763 0004 FB 52 00 00 00 00       		mov.L	#_can_state, r5
 764 000a EC 55                   		mov.L	[r5], r5
 398:../src/can.c  ****         {
 765                             		.loc 1 398 12 view .LVU244
 766 000c 61 45                   		cmp	#4, r5
 767 000e 21 03                   		bne	.L43
 768                             	.L40:
 422:../src/can.c  **** 
 769                             		.loc 1 422 1 view .LVU245
 770 0010 02                      		rts
 771                             	.L43:
 403:../src/can.c  ****             #endif
 772                             		.loc 1 403 13 is_stmt 1 view .LVU246
 773 0011 05 00 00 00             		bsr	_can_int_demo
 774                             	.LVL66:
 413:../src/can.c  ****         /* Reset receive/transmit indication every so often. */
 775                             		.loc 1 413 9 view .LVU247
 415:../src/can.c  ****         {
 776                             		.loc 1 415 9 view .LVU248
 415:../src/can.c  ****         {
 777                             		.loc 1 415 9 is_stmt 0 view .LVU249
 778 0015 2E FB                   		bra	.L40
 779                             	.LFE4:
 781                             		.section	.text.reset_all_errors,"ax",@progbits
 782                             		.global	_reset_all_errors
 784                             	_reset_all_errors:
 785                             	.LVL67:
 786                             	.LFB9:
 772:../src/can.c  ****     uint32_t status = 0;
 787                             		.loc 1 772 1 is_stmt 1 view -0
 773:../src/can.c  **** 
 788                             		.loc 1 773 5 view .LVU251
 776:../src/can.c  **** 
 789                             		.loc 1 776 5 view .LVU252
 776:../src/can.c  **** 
 790                             		.loc 1 776 16 is_stmt 0 view .LVU253
 791 0000 FB 52 00 00 00 00       		mov.L	#_app_err_nr, r5
 792 0006 F8 56 00                		mov.L	#0, [r5]
 778:../src/can.c  ****     error_bus_status[1] = 0;
 793                             		.loc 1 778 5 is_stmt 1 view .LVU254
 778:../src/can.c  ****     error_bus_status[1] = 0;
 794                             		.loc 1 778 25 is_stmt 0 view .LVU255
 795 0009 FB 52 00 00 00 00       		mov.L	#_error_bus_status, r5
 796 000f F8 56 00                		mov.L	#0, [r5]
 779:../src/can.c  **** 
 797                             		.loc 1 779 5 is_stmt 1 view .LVU256
 779:../src/can.c  **** 
 798                             		.loc 1 779 25 is_stmt 0 view .LVU257
 799 0012 3E 51 00                		mov.L	#0, 4[r5]
 783:../src/can.c  ****     error_bus_status_prev[1] = 0;
 800                             		.loc 1 783 5 is_stmt 1 view .LVU258
 783:../src/can.c  ****     error_bus_status_prev[1] = 0;
 801                             		.loc 1 783 30 is_stmt 0 view .LVU259
 802 0015 FB 52 00 00 00 00       		mov.L	#_error_bus_status_prev, r5
 803 001b F8 56 00                		mov.L	#0, [r5]
 784:../src/can.c  **** 
 804                             		.loc 1 784 5 is_stmt 1 view .LVU260
 784:../src/can.c  **** 
 805                             		.loc 1 784 30 is_stmt 0 view .LVU261
 806 001e 3E 51 00                		mov.L	#0, 4[r5]
 786:../src/can.c  ****     nr_times_reached_busoff[1] = 0;
 807                             		.loc 1 786 5 is_stmt 1 view .LVU262
 786:../src/can.c  ****     nr_times_reached_busoff[1] = 0;
 808                             		.loc 1 786 32 is_stmt 0 view .LVU263
 809 0021 FB 52 00 00 00 00       		mov.L	#_nr_times_reached_busoff, r5
 810 0027 F8 56 00                		mov.L	#0, [r5]
 787:../src/can.c  **** 
 811                             		.loc 1 787 5 is_stmt 1 view .LVU264
 787:../src/can.c  **** 
 812                             		.loc 1 787 32 is_stmt 0 view .LVU265
 813 002a 3E 51 00                		mov.L	#0, 4[r5]
 790:../src/can.c  **** 
 814                             		.loc 1 790 5 is_stmt 1 view .LVU266
 790:../src/can.c  **** 
 815                             		.loc 1 790 20 is_stmt 0 view .LVU267
 816 002d FB 5E 00 02 09          		mov.L	#0x90200, r5
 817 0032 FA 54 4D 06 00          		mov.B	#0, 1613[r5]
 793:../src/can.c  **** 
 818                             		.loc 1 793 5 is_stmt 1 view .LVU268
 793:../src/can.c  **** 
 819                             		.loc 1 793 20 is_stmt 0 view .LVU269
 820 0037 FA 54 50 06 00          		mov.B	#0, 1616[r5]
 796:../src/can.c  ****     CAN0.TECR = 0;
 821                             		.loc 1 796 5 is_stmt 1 view .LVU270
 796:../src/can.c  ****     CAN0.TECR = 0;
 822                             		.loc 1 796 15 is_stmt 0 view .LVU271
 823 003c FA 54 4E 06 00          		mov.B	#0, 1614[r5]
 797:../src/can.c  **** 
 824                             		.loc 1 797 5 is_stmt 1 view .LVU272
 797:../src/can.c  **** 
 825                             		.loc 1 797 15 is_stmt 0 view .LVU273
 826 0041 FA 54 4F 06 00          		mov.B	#0, 1615[r5]
 799:../src/can.c  **** }/* end reset_all_errors() */
 827                             		.loc 1 799 5 is_stmt 1 view .LVU274
 800:../src/can.c  **** 
 828                             		.loc 1 800 1 is_stmt 0 view .LVU275
 829 0046 66 01                   		mov.L	#0, r1
 830                             	.LVL68:
 800:../src/can.c  **** 
 831                             		.loc 1 800 1 view .LVU276
 832 0048 02                      		rts
 833                             	.LFE9:
 835                             		.section	.text.my_can_err1_callback,"ax",@progbits
 836                             		.global	_my_can_err1_callback
 838                             	_my_can_err1_callback:
 839                             	.LFB14:
 973:../src/can.c  ****     /* Error interrupt can have multiple sources. Check interrupt flags to id source. */
 840                             		.loc 1 973 1 is_stmt 1 view -0
 975:../src/can.c  ****     {
 841                             		.loc 1 975 5 view .LVU278
 975:../src/can.c  ****     {
 842                             		.loc 1 975 9 is_stmt 0 view .LVU279
 843 0000 FB 5E 00 70 08          		mov.L	#0x87000, r5
 844 0005 EE 55 80 01             		mov.L	1536[r5], r5
 975:../src/can.c  ****     {
 845                             		.loc 1 975 8 view .LVU280
 846 0009 FD 74 C5 02             		tst	#2, r5
 847 000d 20 12                   		beq	.L45
1003:../src/can.c  **** 
 848                             		.loc 1 1003 9 is_stmt 1 view .LVU281
 849                             	 ; 1003 "../src/can.c" 1
 850 000f 03                      		nop
 851                             	 ; 0 "" 2
1006:../src/can.c  ****     }
 852                             		.loc 1 1006 9 view .LVU282
1006:../src/can.c  ****     }
 853                             		.loc 1 1006 25 is_stmt 0 view .LVU283
 854 0010 FB 5E 00 70 08          		mov.L	#0x87000, r5
 855 0015 EE 54 A0 01             		mov.L	1664[r5], r4
 856 0019 78 14                   		bset	#1, r4
 857 001b EB 54 A0 01             		mov.L	r4, 1664[r5]
 858                             	.L45:
1008:../src/can.c  **** #endif
 859                             		.loc 1 1008 1 view .LVU284
 860 001f 02                      		rts
 861                             	.LFE14:
 863                             		.section	.text.my_sw_charput_function,"ax",@progbits
 864                             		.global	_my_sw_charput_function
 866                             	_my_sw_charput_function:
 867                             	.LVL69:
 868                             	.LFB16:
1095:../src/can.c  **** 
1096:../src/can.c  **** #define NOP __asm__ volatile("nop;");
1097:../src/can.c  **** /* AP add */
1098:../src/can.c  **** void my_sw_charput_function(char output_char)
1099:../src/can.c  **** {
 869                             		.loc 1 1099 1 is_stmt 1 view -0
1100:../src/can.c  **** 	NOP;
 870                             		.loc 1 1100 2 view .LVU286
 871                             	 ; 1100 "../src/can.c" 1
 872 0000 03                      		nop;
 873                             	 ; 0 "" 2
 874                             		.loc 1 1100 5 view .LVU287
1101:../src/can.c  **** }
 875                             		.loc 1 1101 1 is_stmt 0 view .LVU288
 876 0001 02                      		rts
 877                             	.LFE16:
 879                             		.section	.bss.nr_frames_tx,"aw",@nobits
 880                             		.balign 4
 883                             	_nr_frames_tx:
 884 0000 00 00 00 00             		.zero	4
 885                             		.section	.bss.nr_frames_rx,"aw",@nobits
 886                             		.balign 4
 889                             	_nr_frames_rx:
 890 0000 00 00 00 00             		.zero	4
 891                             		.section	.bss.nr_times_reached_busoff,"aw",@nobits
 892                             		.balign 4
 895                             	_nr_times_reached_busoff:
 896 0000 00 00 00 00 00 00 00 00 		.zero	12
 896      00 00 00 00 
 897                             		.section	.bss.can_state,"aw",@nobits
 898                             		.balign 4
 901                             	_can_state:
 902 0000 00 00 00 00 00 00 00 00 		.zero	12
 902      00 00 00 00 
 903                             		.section	.bss.error_bus_status_prev,"aw",@nobits
 904                             		.balign 4
 907                             	_error_bus_status_prev:
 908 0000 00 00 00 00 00 00 00 00 		.zero	12
 908      00 00 00 00 
 909                             		.section	.bss.error_bus_status,"aw",@nobits
 910                             		.balign 4
 913                             	_error_bus_status:
 914 0000 00 00 00 00 00 00 00 00 		.zero	12
 914      00 00 00 00 
 915                             		.comm	_app_err_nr,4,4
 916                             		.global	_CAN0_rx_remote_frame_flag
 917                             		.section	.bss.CAN0_rx_remote_frame_flag,"aw",@nobits
 918                             		.balign 4
 921                             	_CAN0_rx_remote_frame_flag:
 922 0000 00 00 00 00             		.zero	4
 923                             		.global	_CAN0_tx_remote_sentdata_flag
 924                             		.section	.bss.CAN0_tx_remote_sentdata_flag,"aw",@nobits
 925                             		.balign 4
 928                             	_CAN0_tx_remote_sentdata_flag:
 929 0000 00 00 00 00             		.zero	4
 930                             		.global	_CAN0_rx_newdata_flag
 931                             		.section	.bss.CAN0_rx_newdata_flag,"aw",@nobits
 932                             		.balign 4
 935                             	_CAN0_rx_newdata_flag:
 936 0000 00 00 00 00             		.zero	4
 937                             		.global	_CAN0_tx_sentdata_flag
 938                             		.section	.bss.CAN0_tx_sentdata_flag,"aw",@nobits
 939                             		.balign 4
 942                             	_CAN0_tx_sentdata_flag:
 943 0000 00 00 00 00             		.zero	4
 944                             		.comm	_CAN0_bitrate_cfg,4,1
 945                             		.global	_g_mb_mode
 946                             		.section	.bss.g_mb_mode,"aw",@nobits
 947                             		.balign 4
 950                             	_g_mb_mode:
 951 0000 00 00 00 00             		.zero	4
 952                             		.global	_g_can_channel
 953                             		.section	.bss.g_can_channel,"aw",@nobits
 954                             		.balign 4
 957                             	_g_can_channel:
 958 0000 00 00 00 00             		.zero	4
 959                             		.comm	_remote_frame,16,4
 960                             		.comm	_rx_dataframe6,16,4
 961                             		.comm	_rx_dataframe5,16,4
 962                             		.comm	_rx_dataframe4,16,4
 963                             		.comm	_rx_dataframe3,16,4
 964                             		.comm	_rx_dataframe2,16,4
 965                             		.comm	_rx_dataframe1,16,4
 966                             		.comm	_tx_dataframe,16,4
 1145                             	.Letext0:
 1146                             		.file 2 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 1147                             		.file 3 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 1148                             		.file 4 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
 1149                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 1150                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 1151                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
 1152                             		.file 8 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_bsp/mcu/all/r_rx_compi
 1153                             		.file 9 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_bsp/mcu/rx72n/register
 1154                             		.file 10 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_bsp/mcu/rx72n/mcu_loc
 1155                             		.file 11 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_can_rx/r_can_rx_if.h"
 1156                             		.file 12 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src/aprx72n0a.h"
 1157                             		.file 13 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src/can.h"
