   1                             		.file	"PIDConf.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.section	.text.r_emwin_rx_pidconf_cb,"ax",@progbits
   5                             		.global	_r_emwin_rx_pidconf_cb
   7                             	_r_emwin_rx_pidconf_cb:
   8                             	.LVL0:
   9                             	.LFB3:
  10                             		.file 1 "../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c"
   1:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
   2:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * DISCLAIMER
   3:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * This software is supplied by Renesas Electronics Corporation and is only intended for use with R
   4:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * other uses are authorized. This software is owned by Renesas Electronics Corporation and is prot
   5:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * applicable laws, including copyright laws.
   6:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
   7:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
   8:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAI
   9:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS A
  10:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY R
  11:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DA
  12:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Renesas reserves the right, without notice, to make changes to this software and to discontinue 
  13:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * this software. By using this software, you agree to the additional terms and conditions found by
  14:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * following link:
  15:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * http://www.renesas.com/disclaimer
  16:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *
  17:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Copyright (C) 2023 Renesas Electronics Corporation. All rights reserved.
  18:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  19:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
  20:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * File Name    : PIDConf.c
  21:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Version      : 1.00
  22:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Touch panel configuration.
  23:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  24:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
  25:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * History : DD.MM.YYYY Version        Description
  26:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *         : 31.07.2020 6.14.a.1.00    First Release
  27:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *         : 04.09.2020 6.14.a.1.10    Update to adjust r_emwin_rx_config.h file.
  28:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *         : 11.12.2020 6.14.g.1.20    Update to adjust emWin v6.14g. Modify multi-touch and timer 
  29:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                                     Adjust GCC and IAR compilers.
  30:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *         : 31.03.2021 6.14.g.1.30    Update to adjust the spec of Smart Configurator and QE for D
  31:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *         : 29.12.2021 6.20.  1.00    Update emWin library to v6.22.
  32:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                                     Adjust configuration option with Smart Configurator.
  33:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *         : 31.08.2022 6.26.c.1.00    Update emWin library to v6.26c.
  34:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                                     Supports touch screen orientation.
  35:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                                     Supports SPI interface.
  36:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                                     Fixed the problem that touch is falsely detected after initi
  37:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                                     when using SCI-IIC interface.
  38:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *         : 31.03.2023 6.32.a.1.00    Update emWin library to v6.32a.
  39:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                                     Fixed related to runtime orientation.
  40:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  41:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  42:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
  43:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  Includes   <System Includes> , "Project Includes"
  44:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  45:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #include "GUI.h"
  46:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #include "GUIConf.h"
  47:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  48:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #include "r_gpio_rx_if.h"
  49:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #include "r_emwin_rx_config.h"
  50:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #include "../../src/r_emwin_rx_private.h"
  51:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  52:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
  53:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  Macro definitions
  54:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  55:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  56:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
  57:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  Local Typedef definitions
  58:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  59:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_TOUCH == 1)
  60:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /* Holds information about coordinates and ID. */
  61:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** typedef struct
  62:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
  63:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t x_high;       /* Bit 6..7 - EventFlag, Bit 0..3 x_high */
  64:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t x_low;
  65:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t y_high;       /* Bit 4..7 - TouchID, Bit 0..3 y_high */
  66:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t y_low;
  67:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t id;
  68:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** } st_touch_data_t;
  69:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  70:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /* Holds information about different touch points, mode, gesture and number of points. */
  71:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** typedef struct
  72:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
  73:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t device_mode;
  74:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t gesture_id;
  75:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t num_points;
  76:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** } st_report_data_t;
  77:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  78:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /*  Used by this module to calculate the different MT flags and events. */
  79:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** typedef struct
  80:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
  81:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint16_t x_pos;
  82:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint16_t y_pos;
  83:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t  id;
  84:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** } st_point_data_t;
  85:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  86:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif /* (EMWIN_USE_TOUCH == 1) */
  87:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  88:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
  89:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  Exported global variables
  90:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  91:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  92:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
  93:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  Private (static) variables and functions
  94:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
  95:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_TOUCH == 1)
  96:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  97:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static int32_t s_layer_index;
  98:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
  99:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_RUNTIME_ORIENTATION == 0)
 100:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /* Manually convert each orientation to a base point. */
 101:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static volatile uint8_t s_touch_orientation = EMWIN_DISPLAY_ORIENTATION;
 102:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #else
 103:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /* Automatically converted in AppWizard and Window Manager based on ORIENTATION_0. */
 104:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static volatile uint8_t s_touch_orientation = ORIENTATION_0;
 105:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 106:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 107:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_MULTITOUCH == 0)
 108:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 109:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static e_emwin_rx_err_t pidconf_cb_single(uint8_t * p_addr, uint32_t size);
 110:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 111:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #else /* (EMWIN_USE_MULTITOUCH == 1) */
 112:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 113:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static uint8_t s_a_active_ids[EMWIN_MAX_NUM_TOUCHPOINTS];
 114:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static e_emwin_rx_err_t pidconf_cb_multi(uint8_t * p_addr, uint32_t size);
 115:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 116:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if ((EMWIN_TOUCH_IF == TOUCH_IF_SCI_SPI) || (EMWIN_TOUCH_IF == TOUCH_IF_RSPI))
 117:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #error "Error!! Multitouch function is not available for serial touch interfaces!"
 118:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 119:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 120:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 121:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 122:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif /* (EMWIN_USE_TOUCH == 1) */
 123:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 124:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 125:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 126:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_TOUCH == 1)
 127:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_MULTITOUCH == 0)
 128:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_TOUCH_IF == TOUCH_IF_SCI_IIC)
 129:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 130:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: check_initial_touch
 131:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Check whether the touch state is after initialization.
 132:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : report -
 133:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              :     touch status.
 134:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : 0 -
 135:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              :     Touch state after initialization.
 136:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              : 1 -
 137:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              :     Not in touch state after initialization.
 138:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 139:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static uint8_t check_initial_touch(st_report_data_t report)
 140:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 141:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     volatile static uint8_t s_first_state  = 0;
 142:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     volatile static uint8_t s_second_state = 0;
 143:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     volatile static st_report_data_t s_first_report;
 144:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 145:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if ( !s_first_state)
 146:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 147:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_first_report = report;
 148:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_first_state = 1;
 149:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         return 0;
 150:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 151:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 152:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if ( !s_second_state)
 153:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 154:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if ((s_first_report.num_points == report.num_points) && (s_first_report.gesture_id == repor
 155:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 156:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             return 0;
 157:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 158:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_second_state = 1;
 159:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 160:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 161:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return 1;
 162:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 163:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 164:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function check_initial_touch
 165:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 166:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 167:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 168:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: pidconf_cb_single
 169:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Functions for IIC interface and single touch.
 170:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 171:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 172:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 173:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static e_emwin_rx_err_t pidconf_cb_single(uint8_t * p_addr, uint32_t size)
 174:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 175:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     static GUI_PID_STATE s_state_pid;
 176:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     static int32_t       s_is_touched;
 177:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     st_report_data_t     report;
 178:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     st_touch_data_t      touch_point;
 179:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t *            p_buffer;
 180:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     e_emwin_rx_err_t     emwin_ret = EMWIN_RX_SUCCESS;
 181:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int temp;
 182:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 183:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 184:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Handle just one touch info. */
 185:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     s_state_pid.Layer  = s_layer_index;          /* Set layer who should handle touch */
 186:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_buffer           =  p_addr;
 187:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     report.device_mode = *p_buffer++;            /* Get device mode, 000b - Work Mode, 001b - Facto
 188:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     report.gesture_id  = *p_buffer++;            /* GestureID:  0x10 Move UP
 189:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x14 Move Left
 190:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x18 Move Down
 191:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x1C Move Right
 192:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x48 Zoom In
 193:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x49 Zoom Out
 194:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x00 No Gesture */
 195:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     report.num_points   = *p_buffer++;           /* Number of points */
 196:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     touch_point.x_high  = (*p_buffer ++) & 0x0F; /* Get the upper 4 bits of the x position */
 197:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     touch_point.x_low   = *p_buffer++;           /* and the lower 8 bits */
 198:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     touch_point.y_high  = (*p_buffer ++) & 0x0F; /* Get the upper 4 bits of the y position */
 199:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     touch_point.y_low   = *p_buffer++;           /* and the lower 8 bits */
 200:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 201:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Check detection after initialization */
 202:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if(0 == check_initial_touch(report))
 203:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 204:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         return emwin_ret;
 205:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 206:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 207:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Check if we have a touch detected */
 208:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if (report.num_points)
 209:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 210:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_is_touched        = 1; /* Remember that we have a touch, needed for generating up events 
 211:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_state_pid.Pressed = 1; /* State is pressed */
 212:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 213:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* Shift bits for x- and y- coordinate to the correct position */
 214:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_state_pid.x       = (((touch_point.x_high & 0x0F) << 8) | touch_point.x_low);
 215:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_state_pid.y       = (((touch_point.y_high & 0x0F) << 8) | touch_point.y_low);
 216:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 217:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* Touch orientation */
 218:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (ORIENTATION_0 == s_touch_orientation)
 219:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 220:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             R_BSP_NOP(); /* no operation */
 221:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 222:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else if (ORIENTATION_CW == s_touch_orientation)
 223:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 224:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* X - Mirror */
 225:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = (EMWIN_XSIZE_PHYS - 1) - s_state_pid.x;
 226:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 227:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* XY Swap */
 228:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             temp          = s_state_pid.x;
 229:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = s_state_pid.y;
 230:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = temp;
 231:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 232:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 233:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else if (ORIENTATION_180 == s_touch_orientation)
 234:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 235:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* X - Mirror */
 236:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = (EMWIN_XSIZE_PHYS - 1) - s_state_pid.x;
 237:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 238:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Y - Mirror */
 239:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = (EMWIN_YSIZE_PHYS - 1) - s_state_pid.y;
 240:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 241:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 242:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else if (ORIENTATION_CCW == s_touch_orientation)
 243:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 244:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Y - Mirror */
 245:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = (EMWIN_YSIZE_PHYS - 1) - s_state_pid.y;
 246:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 247:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* XY Swap */
 248:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             temp          = s_state_pid.x;
 249:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = s_state_pid.y;
 250:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = temp;
 251:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 252:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else
 253:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 254:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             R_BSP_NOP(); /* no operation */
 255:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 256:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 257:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* Pass touch data to emWin */
 258:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         GUI_TOUCH_StoreStateEx(&s_state_pid);
 259:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 260:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     else
 261:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 262:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (s_is_touched)
 263:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {                            /* If we had a touch, */
 264:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_is_touched        = 0; /* now we don't. */
 265:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.Pressed = 0; /* So, state is not pressed. */
 266:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 267:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Tell emWin */
 268:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             GUI_TOUCH_StoreStateEx(&s_state_pid);
 269:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 270:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 271:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 272:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return emwin_ret;
 273:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 274:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 275:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function pidconf_cb_single
 276:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 277:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 278:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #elif ((EMWIN_TOUCH_IF == TOUCH_IF_SCI_SPI) || (EMWIN_TOUCH_IF == TOUCH_IF_RSPI))
 279:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 280:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: pidconf_cb_single
 281:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Functions for SPI interface and single touch.
 282:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 283:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 284:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 285:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static e_emwin_rx_err_t pidconf_cb_single(uint8_t * p_addr, uint32_t size)
 286:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 287:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     e_emwin_rx_err_t     emwin_ret = EMWIN_RX_SUCCESS;
 288:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     static GUI_PID_STATE s_state_pid;
 289:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     static int32_t       s_is_touched;
 290:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint16_t             xpos;
 291:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint16_t             ypos;
 292:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t              press;
 293:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int                  temp;
 294:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 295:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Handle just one touch info. */
 296:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     s_state_pid.Layer  = s_layer_index;          /* Set layer who should handle touch */
 297:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 298:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     xpos  = ((uint16_t)(p_addr[0] << 8) + ((uint16_t)(p_addr[1])));
 299:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     ypos  = ((uint16_t)(p_addr[2] << 8) + ((uint16_t)(p_addr[3])));
 300:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     press = p_addr[4];
 301:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 302:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Check if we have a touch detected */
 303:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if (press)
 304:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 305:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_is_touched        = 1; /* Remember that we have a touch, needed for generating up events 
 306:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_state_pid.Pressed = 1; /* State is pressed */
 307:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 308:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* Shift bits for x- and y- coordinate to the correct position */
 309:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_state_pid.x       = xpos;
 310:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_state_pid.y       = ypos;
 311:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 312:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* Touch orientation */
 313:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (ORIENTATION_0 == s_touch_orientation)
 314:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 315:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             R_BSP_NOP(); /* no operation */
 316:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 317:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else if (ORIENTATION_CW == s_touch_orientation)
 318:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 319:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* X - Mirror */
 320:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = (EMWIN_XSIZE_PHYS - 1) - s_state_pid.x;
 321:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 322:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* XY Swap */
 323:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             temp          = s_state_pid.x;
 324:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = s_state_pid.y;
 325:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = temp;
 326:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 327:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else if (ORIENTATION_180 == s_touch_orientation)
 328:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 329:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* X - Mirror */
 330:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = (EMWIN_XSIZE_PHYS - 1) - s_state_pid.x;
 331:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 332:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Y - Mirror */
 333:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = (EMWIN_YSIZE_PHYS - 1) - s_state_pid.y;
 334:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 335:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else if (ORIENTATION_CCW == s_touch_orientation)
 336:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 337:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Y - Mirror */
 338:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = (EMWIN_YSIZE_PHYS - 1) - s_state_pid.y;
 339:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 340:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* XY Swap */
 341:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             temp          = s_state_pid.x;
 342:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.x = s_state_pid.y;
 343:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.y = temp;
 344:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 345:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else
 346:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 347:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             R_BSP_NOP(); /* no operation */
 348:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 349:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 350:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* Pass touch data to emWin */
 351:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         GUI_TOUCH_StoreStateEx(&s_state_pid);
 352:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 353:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     else
 354:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 355:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (s_is_touched)
 356:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {                            /* If we had a touch, */
 357:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_is_touched        = 0; /* now we don't. */
 358:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             s_state_pid.Pressed = 0; /* So, state is not pressed. */
 359:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 360:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Tell emWin */
 361:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             GUI_TOUCH_StoreStateEx(&s_state_pid);
 362:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 363:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 364:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 365:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return emwin_ret;
 366:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 367:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 368:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function pidconf_cb_single
 369:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 370:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 371:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #else /* (EMWIN_TOUCH_IF == TOUCH_IF_OTHER) */
 372:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 373:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #warning "Warning!! Please implement pidconf_cb_single() function!"
 374:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 375:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 376:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: pidconf_cb_single
 377:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : User definition function.
 378:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 379:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 380:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 381:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static e_emwin_rx_err_t pidconf_cb_single(uint8_t * p_addr, uint32_t size)
 382:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 383:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     e_emwin_rx_err_t emwin_ret = EMWIN_RX_SUCCESS;
 384:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 385:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* user program */
 386:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 387:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return emwin_ret;
 388:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 389:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 390:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function pidconf_cb_single
 391:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 392:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 393:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 394:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #else /* EMWIN_USE_MULTITOUCH == 0 */
 395:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 396:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 397:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: active_id_found
 398:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Checks if the given ID is part of the currently active IDs.
 399:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 400:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 401:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 402:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static int32_t active_id_found(uint8_t id)
 403:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 404:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t i;
 405:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t * p_id;
 406:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 407:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_id = s_a_active_ids;
 408:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     i    = GUI_COUNTOF(s_a_active_ids);
 409:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     do
 410:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 411:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (*p_id++ == id)
 412:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 413:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             return 1;
 414:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 415:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     } while (--i); /* WAIT_LOOP */
 416:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 417:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return 0;
 418:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 419:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 420:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function active_id_found
 421:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 422:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 423:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 424:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: store_id
 425:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Finds a free 'slot' for the given ID and puts it to the active IDs.
 426:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 427:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 428:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 429:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static int32_t store_id(uint8_t id)
 430:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 431:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t i;
 432:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t * p_id;
 433:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 434:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_id = s_a_active_ids;
 435:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     i    = GUI_COUNTOF(s_a_active_ids);
 436:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     do
 437:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 438:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (*p_id == 0)
 439:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 440:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             *p_id = id;
 441:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             return 0;
 442:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 443:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_id++;
 444:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     } while (--i); /* WAIT_LOOP */
 445:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 446:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return 1;
 447:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 448:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 449:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function store_id
 450:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 451:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 452:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 453:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: current_id_found
 454:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Checks if the given ID is part of the given st_point_data_t array.
 455:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 456:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 457:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 458:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static int32_t current_id_found(uint8_t id, st_point_data_t * p_point_data, int32_t num_points)
 459:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 460:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     st_point_data_t * p_i;
 461:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t i;
 462:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 463:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* WAIT_LOOP */
 464:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     for (p_i = p_point_data, i = 0; i < num_points; i++, p_i++)
 465:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 466:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (p_i->id == id)
 467:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 468:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             return 1;
 469:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 470:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 471:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 472:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return 0;
 473:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 474:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 475:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function current_id_found
 476:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 477:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 478:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 479:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: create_input
 480:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : .
 481:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 482:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : Fills the given GUI_MTOUCH_INPUT structure with the given coordinates
 483:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                of the st_point_data_t data structure. In case of UP events there is no
 484:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                data and only the given ID is used.
 485:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 486:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static void create_input(uint16_t flags, uint8_t id, st_point_data_t * p_point_data, GUI_MTOUCH_INP
 487:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 488:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if (p_point_data)
 489:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 490:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_input->x  = p_point_data->x_pos;
 491:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_input->y  = p_point_data->y_pos;
 492:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_input->Id = p_point_data->id;
 493:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 494:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     else
 495:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 496:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_input->Id = id;
 497:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 498:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_input->Flags = flags;
 499:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 500:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 501:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function create_input
 502:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 503:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 504:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 505:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: create_up_inputs
 506:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Checks if the already existing active touch points exist in current
 507:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                data. For each non existing active ID in the current data an UP event
 508:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                is created.
 509:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 510:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 511:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 512:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static void create_up_inputs(st_point_data_t * p_point_data, int32_t num_points,
 513:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                             GUI_MTOUCH_INPUT ** pp_input, int32_t * p_num_inputs)
 514:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 515:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_MTOUCH_INPUT * p_input;
 516:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t i;
 517:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t * p_id;
 518:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t id;
 519:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 520:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_input = *pp_input;
 521:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_id = s_a_active_ids;
 522:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     i   = GUI_COUNTOF(s_a_active_ids);
 523:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     do
 524:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 525:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         id = *p_id;
 526:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (id)
 527:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 528:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             if (current_id_found(id, p_point_data, num_points) == 0)
 529:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             {
 530:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 create_input(GUI_MTOUCH_FLAG_UP, id, NULL, p_input);
 531:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 (*p_num_inputs)++;
 532:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 p_input++;
 533:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 *p_id = 0;
 534:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             }
 535:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 536:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_id++;
 537:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     } while (--i); /* WAIT_LOOP */
 538:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     *pp_input = p_input;
 539:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 540:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 541:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function create_up_inputs
 542:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 543:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 544:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 545:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: create_move_and_down_inputs
 546:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Fills the given array of GUI_MTOUCH_INPUT structures with data of current
 547:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                st_point_data_t array. If an item already exist a MOVE event is created,
 548:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *                otherwise a DOWM event.
 549:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 550:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 551:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 552:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static void create_move_and_down_inputs(st_point_data_t * p_point_data, int32_t num_points, GUI_MTO
 553:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 554:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t i;
 555:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t found;
 556:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 557:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* WAIT_LOOP */
 558:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     for (i = 0; i < num_points; i++, p_point_data++, p_input++)
 559:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 560:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         found       = active_id_found(p_point_data->id);
 561:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_input->x  = p_point_data->x_pos;
 562:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_input->y  = p_point_data->y_pos;
 563:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         p_input->Id = p_point_data->id;
 564:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if (found)
 565:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 566:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             p_input->Flags = GUI_MTOUCH_FLAG_MOVE;
 567:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 568:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         else
 569:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 570:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             p_input->Flags = GUI_MTOUCH_FLAG_DOWN;
 571:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             store_id(p_point_data->id);
 572:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 573:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 574:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 575:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 576:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function create_move_and_down_inputs
 577:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 578:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 579:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 580:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: check_initial_touch
 581:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Check whether the touch state is after initialization.
 582:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : report -
 583:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              :     touch status.
 584:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : 0 -
 585:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              :     Touch state after initialization.
 586:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              : 1 -
 587:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  *              :     Not in touch state after initialization.
 588:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 589:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static uint8_t check_initial_touch(st_report_data_t report)
 590:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 591:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     volatile static uint8_t s_first_state  = 0;
 592:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     volatile static uint8_t s_second_state = 0;
 593:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     volatile static st_report_data_t s_first_report;
 594:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 595:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if ( !s_first_state)
 596:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 597:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_first_report = report;
 598:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_first_state = 1;
 599:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         return 0;
 600:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 601:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 602:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if ( !s_second_state)
 603:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 604:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         if ((s_first_report.num_points == report.num_points) && (s_first_report.gesture_id == repor
 605:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 606:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             return 0;
 607:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 608:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         s_second_state = 1;
 609:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 610:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 611:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return 1;
 612:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 613:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 614:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function check_initial_touch
 615:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 616:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 617:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 618:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: pidconf_cb_multi
 619:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : .
 620:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 621:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 622:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 623:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** static e_emwin_rx_err_t pidconf_cb_multi(uint8_t * p_addr, uint32_t size)
 624:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
 625:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_MTOUCH_INPUT    * p_input;
 626:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_MTOUCH_EVENT    event;
 627:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_MTOUCH_INPUT    a_input[EMWIN_MAX_NUM_TOUCHPOINTS];
 628:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     st_point_data_t     a_point_data[EMWIN_MAX_NUM_TOUCHPOINTS];
 629:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     st_report_data_t    report;
 630:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     st_touch_data_t     touch_point;
 631:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t             num_inputs;
 632:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t             i;
 633:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t             num_points = 0;
 634:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t             x_coord;
 635:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t             y_coord;
 636:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     uint8_t             * p_buffer;
 637:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     e_emwin_rx_err_t      emwin_ret = EMWIN_RX_SUCCESS;
 638:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     int32_t             temp;
 639:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 640:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_buffer           =  p_addr;
 641:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     report.device_mode = *p_buffer++;            /* Get device mode, 000b - Work Mode, 001b - Facto
 642:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     report.gesture_id  = *p_buffer++;            /* GestureID:  0x10 Move UP
 643:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x14 Move Left
 644:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x18 Move Down
 645:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x1C Move Right
 646:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x48 Zoom In
 647:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x49 Zoom Out
 648:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                                                   *             0x00 No Gesture */
 649:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     report.num_points  = *p_buffer++;            /* Number of points */
 650:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 651:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Check detection after initialization */
 652:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if(0 == check_initial_touch(report))
 653:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 654:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         return emwin_ret;
 655:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 656:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 657:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Check max number touch points */
 658:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if(report.num_points <= EMWIN_MAX_NUM_TOUCHPOINTS)
 659:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 660:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         num_points     =  report.num_points;
 661:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 662:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 663:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Reading point data is only required if there is a touch point */
 664:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if (num_points)
 665:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 666:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* Get coordinates and IDs from buffer */
 667:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         /* WAIT_LOOP */
 668:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         for (i = 0; i < num_points; i++)
 669:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         {
 670:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             touch_point.x_high  = (*p_buffer++) & 0x0F; /* Get the upper 4 bits of the x position *
 671:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             touch_point.x_low   =  *p_buffer++;         /* and the lower 8 bits */
 672:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             touch_point.id      = (*p_buffer)   & 0xF0; /* Extract the touch point ID */
 673:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             touch_point.y_high  = (*p_buffer++) & 0x0F; /* Get the upper 4 bits of the y position *
 674:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             touch_point.y_low   =  *p_buffer++;         /* and the lower 8 bits */
 675:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 676:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Increment buffer twice since we have two dummy bytes */
 677:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             p_buffer++;
 678:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             p_buffer++;
 679:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 680:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Calculate coordinate values */
 681:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             x_coord = ((touch_point.x_high & 0x0F) << 8 | touch_point.x_low);
 682:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             y_coord = ((touch_point.y_high & 0x0F) << 8 | touch_point.y_low);
 683:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 684:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Touch orientation */
 685:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             if (ORIENTATION_0 == s_touch_orientation)
 686:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             {
 687:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 R_BSP_NOP(); /* no operation */
 688:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             }
 689:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             else if (ORIENTATION_CW == s_touch_orientation)
 690:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             {
 691:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 /* X - Mirror */
 692:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 x_coord = (EMWIN_XSIZE_PHYS - 1) - x_coord;
 693:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 694:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 /* XY Swap */
 695:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 temp    = x_coord;
 696:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 x_coord = y_coord;
 697:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 y_coord = temp;
 698:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 699:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             }
 700:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             else if (ORIENTATION_180 == s_touch_orientation)
 701:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             {
 702:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 /* X - Mirror */
 703:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 x_coord = (EMWIN_XSIZE_PHYS - 1) - x_coord;
 704:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 705:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 /* Y - Mirror */
 706:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 y_coord = (EMWIN_YSIZE_PHYS - 1) - y_coord;
 707:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 708:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             }
 709:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             else if (ORIENTATION_CCW == s_touch_orientation)
 710:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             {
 711:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 /* Y - Mirror */
 712:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 y_coord = (EMWIN_YSIZE_PHYS - 1) - y_coord;
 713:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 714:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 /* XY Swap */
 715:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 temp    = x_coord;
 716:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 x_coord = y_coord;
 717:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 y_coord = temp;
 718:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             }
 719:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             else
 720:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             {
 721:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****                 R_BSP_NOP(); /* no operation */
 722:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             }
 723:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 724:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             /* Add 1 to ID because TC counts from 0 and emWin can't handle an ID with 0 */
 725:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             a_point_data[i].id    = touch_point.id + 1;
 726:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             a_point_data[i].x_pos = x_coord;
 727:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****             a_point_data[i].y_pos = y_coord;
 728:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         }
 729:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 730:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 731:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Independent of num_points check if UP-inputs need to be generated */
 732:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     p_input    = a_input;
 733:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     num_inputs = 0;
 734:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     create_up_inputs(a_point_data, num_points, &p_input, &num_inputs);
 735:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 736:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Create MOVE- and DOWN-inputs only for current points */
 737:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if (num_points)
 738:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 739:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         create_move_and_down_inputs(a_point_data, num_points, p_input);
 740:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         num_inputs += num_points;
 741:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 742:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 743:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* If any input exists, store an event into emWin buffer */
 744:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if (num_inputs)
 745:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 746:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         event.LayerIndex = s_layer_index;
 747:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         event.NumPoints  = num_inputs;
 748:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         GUI_MTOUCH_StoreEvent(&event, a_input);
 749:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 750:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 751:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return emwin_ret;
 752:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
 753:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 754:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function pidconf_cb_multi
 755:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 756:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif /* EMWIN_USE_MULTITOUCH == 0 */
 757:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif /* EMWIN_USE_TOUCH == 1 */
 758:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 759:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 760:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: r_emwin_rx_pidconf_cb
 761:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : .
 762:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 763:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 764:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 765:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** e_emwin_rx_err_t r_emwin_rx_pidconf_cb(uint8_t * p_addr, uint32_t size)
 766:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
  11                             		.loc 1 766 1 view -0
 767:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     e_emwin_rx_err_t     emwin_ret = EMWIN_RX_SUCCESS;
  12                             		.loc 1 767 5 view .LVU1
 768:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_TOUCH == 1)
 769:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_MULTITOUCH == 0)
 770:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     emwin_ret = pidconf_cb_single(p_addr, size);
 771:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #else /* EMWIN_USE_MULTITOUCH == 1 */
 772:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     emwin_ret = pidconf_cb_multi(p_addr, size);
 773:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif /* EMWIN_USE_MULTITOUCH == 0 */
 774:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif /* EMWIN_USE_TOUCH == 1 */
 775:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     return emwin_ret;
  13                             		.loc 1 775 5 view .LVU2
 776:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
  14                             		.loc 1 776 1 is_stmt 0 view .LVU3
  15 0000 66 01                   		mov.L	#0, r1
  16                             	.LVL1:
  17                             		.loc 1 776 1 view .LVU4
  18 0002 02                      		rts
  19                             	.LFE3:
  21                             		.section	.text.PID_X_SetLayerIndex,"ax",@progbits
  22                             		.global	_PID_X_SetLayerIndex
  24                             	_PID_X_SetLayerIndex:
  25                             	.LVL2:
  26                             	.LFB4:
 777:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 778:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function r_emwin_rx_pidconf_cb
 779:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 780:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 781:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 782:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: PID_X_SetLayerIndex
 783:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Set layer index.
 784:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 785:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 786:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 787:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** void PID_X_SetLayerIndex(int layer_index)
 788:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
  27                             		.loc 1 788 1 is_stmt 1 view -0
 789:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_TOUCH == 1)
 790:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     s_layer_index = layer_index;
 791:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 792:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
  28                             		.loc 1 792 1 view .LVU6
  29 0000 02                      		rts
  30                             	.LFE4:
  32                             		.section	.text.PID_X_Init,"ax",@progbits
  33                             		.global	_PID_X_Init
  35                             	_PID_X_Init:
  36                             	.LFB5:
 793:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 794:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * End of function PID_X_SetLayerIndex
 795:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 796:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 797:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** /**************************************************************************************************
 798:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Function Name: PID_X_Init
 799:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Description  : Used to initialize Pointer Input Device.
 800:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Arguments    : .
 801:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  * Return Value : .
 802:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****  **************************************************************************************************
 803:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** void PID_X_Init(void)
 804:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** {
  37                             		.loc 1 804 1 view -0
 805:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_TOUCH == 1)
 806:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     e_emwin_rx_err_t pid_ret;
 807:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 808:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_X_Delay(300);
 809:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 810:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_TOUCH_IC_RESET_PIN == 1)
 811:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     /* Reset touch ic */
 812:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     R_GPIO_PinWrite(EMWIN_TOUCH_IC_RESET_PIN, GPIO_LEVEL_LOW);
 813:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     R_GPIO_PinDirectionSet(EMWIN_TOUCH_IC_RESET_PIN, GPIO_DIRECTION_OUTPUT);
 814:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_X_Delay(10);
 815:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     R_GPIO_PinWrite(EMWIN_TOUCH_IC_RESET_PIN, GPIO_LEVEL_HIGH);
 816:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_X_Delay(300);
 817:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 818:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 819:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     pid_ret = r_emwin_rx_pid_open();
 820:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 821:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     if (EMWIN_RX_SUCCESS != pid_ret)
 822:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     {
 823:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****         return; /* Error */
 824:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     }
 825:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** 
 826:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #if (EMWIN_USE_MULTITOUCH == 1)
 827:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c ****     GUI_MTOUCH_Enable(1);
 828:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 829:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** #endif
 830:../src/smc_gen/r_emwin_rx/lib/Config/PIDConf.c **** }
  38                             		.loc 1 830 1 view .LVU8
  39 0000 02                      		rts
  40                             	.LFE5:
  84                             	.Letext0:
  85                             		.file 2 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_emwin_rx\\lib\\GUI/LCD
  86                             		.file 3 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_emwin_rx\\lib\\GUI/GUI
  87                             		.file 4 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_emwin_rx\\lib\\GUI/GUI
  88                             		.file 5 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
  89                             		.file 6 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
  90                             		.file 7 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\lib\\gcc\\rx-
  91                             		.file 8 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
  92                             		.file 9 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\inclu
  93                             		.file 10 "c:\\programdata\\gcc for renesas rx 8.3.0.202311-gnurx-elf\\rx-elf\\rx-elf\\rx-elf\\incl
  94                             		.file 11 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_bsp/mcu/all/r_rx_comp
  95                             		.file 12 "D:\\e2_studio\\workspace\\FULLMONI_WIDE\\Firmware\\src\\smc_gen\\r_bsp/mcu/rx72n/mcu_loc
  96                             		.file 13 "../src/smc_gen/r_emwin_rx/lib/Config/../../src/r_emwin_rx_private.h"
